// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: NeuralNetwork.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2017, Apple Inc. All rights reserved.
//
// Use of this source code is governed by a BSD-3-clause license that can be
// found in LICENSE.txt or at https://opensource.org/licenses/BSD-3-Clause

//*
// A neural network is defined through a collection of layers
// and represents a directed acyclic graph (DAG).
// Each layer has a name, a layer type,
// a list of input names, a list of output names,
// and a collection of parameters specific to the layer type.
//
// The graph structure and connectivity of the neural network
// is inferred from the input and output names.
// A neural network starts with the layer
// whose input name is equal to the value specified in
// ``Model.description.input.name``,
// and ends with the layer
// whose output name is equal to the value specified in
// ``Model.description.output.name``.
// Layers must have unique input and output names,
// and a layer may not have input or output names that
// refer to layers that are not yet defined.
//
// CoreML supports sequential data that can be 1- or 3-dimensional.
// 3-dimensional data typically represents an image feature map,
// whose shape is denoted by ``[C, H, W]``,
// which corresponds to the channel, height, and width, respectively.
// 1-dimensional data is a set of features
// whose shape is denoted by ``[C]``,
// and is equivalent to 3-dimensional data
// with the shape ``[C, 1, 1]``.
//
// For the purposes of this specification,
// batch dimension is ignored.
// Thus, a sequence of 3-dimensional data
// is to be understood as a 4-dimensional array,
// whose shape is denoted by ``[Seq_length, C, H, W]``,
// and a sequence of 1-dimensional data
// is to be understood as a 2-dimensional array,
// whose shape is denoted by ``[Seq_length, C]``,
// which is equivalent to a 4-dimensional array
// with the shape ``[Seq_length, C, 1, 1]``. This axes order is important to
// remember while setting parameters for layers such as "reshape" and "permute".
//
//
// At runtime, all data blobs are internally represented
// as 5-dimensional blobs
// with the shape ``[Seq_length, Batch, C, H, W]``.
//
// A layer may process input data differently if operating over a sequence;
// details of this behavior is documented in the layer's message.
// Otherwise, sequential data is processed like a batch ---
// that is, the sequence of inputs are processed independently and in parallel.
//
// The network input shape specified by ``Model.description.input.type``
// must be compatible with the expected input shape
// of the network input layer, i.e. the last dimension is the fastest moving one.
//
// All data blobs, as well as weight parameters,
// are stored using row-major ordering, i.e. the last dimension is the fastest moving one.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///*
///A neural network.
struct CoreML_Specification_NeuralNetwork {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var layers: [CoreML_Specification_NeuralNetworkLayer] = []

  var preprocessing: [CoreML_Specification_NeuralNetworkPreprocessing] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A neural network preprocessor that
/// performs a scalar multiplication of an image
/// followed by addition of scalar biases to the channels.
///
/// Input: X
///    An image in BGR or RGB format with shape ``[3, H, W]``
///    or in grayscale format with shape ``[1, H, W]``.
/// Output: Y
///    An image with format and shape corresponding to the input.
///
/// If the input image is in BGR format:
///
/// .. code::
///
///     Y[0, :, :] = channelScale * X[0, :, :] + blueBias
///     Y[1, :, :] = channelScale * X[1, :, :] + greenBias
///     Y[2, :, :] = channelScale * X[2, :, :] + redBias
///
/// If the input image is in RGB format:
///
/// .. code::
///
///     Y[0, :, :] = channelScale * X[0, :, :] + redBias
///     Y[1, :, :] = channelScale * X[1, :, :] + greenBias
///     Y[2, :, :] = channelScale * X[2, :, :] + blueBias
///
/// If the input image is in grayscale format:
///
/// .. code::
///
///     Y[0, :, :] = channelScale * X[0, :, :] + grayBias
struct CoreML_Specification_NeuralNetworkImageScaler {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ////Scalar to be multiplied.
  var channelScale: Float = 0

  ////Scalar blue bias to be added.
  var blueBias: Float = 0

  ////Scalar green bias to be added.
  var greenBias: Float = 0

  ////Scalar red bias to be added.
  var redBias: Float = 0

  ////Scalar bias to be added for grayscale images.
  var grayBias: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A neural network preprocessor that
/// subtracts the provided mean image from the input image.
/// The mean image is subtracted from the input named
/// ``NeuralNetworkPreprocessing.featureName``.
struct CoreML_Specification_NeuralNetworkMeanImage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// Mean image stored as a flattened array of floats,
  /// representing shape [Channel,Height,Width].
  var meanImage: [Float] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

//// Preprocessing parameters for image inputs.
struct CoreML_Specification_NeuralNetworkPreprocessing {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// must be equal to the input name to which the preprocessing is applied
  var featureName: String {
    get {return _storage._featureName}
    set {_uniqueStorage()._featureName = newValue}
  }

  var preprocessor: OneOf_Preprocessor? {
    get {return _storage._preprocessor}
    set {_uniqueStorage()._preprocessor = newValue}
  }

  var scaler: CoreML_Specification_NeuralNetworkImageScaler {
    get {
      if case .scaler(let v)? = _storage._preprocessor {return v}
      return CoreML_Specification_NeuralNetworkImageScaler()
    }
    set {_uniqueStorage()._preprocessor = .scaler(newValue)}
  }

  var meanImage: CoreML_Specification_NeuralNetworkMeanImage {
    get {
      if case .meanImage(let v)? = _storage._preprocessor {return v}
      return CoreML_Specification_NeuralNetworkMeanImage()
    }
    set {_uniqueStorage()._preprocessor = .meanImage(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Preprocessor: Equatable {
    case scaler(CoreML_Specification_NeuralNetworkImageScaler)
    case meanImage(CoreML_Specification_NeuralNetworkMeanImage)

  #if !swift(>=4.1)
    static func ==(lhs: CoreML_Specification_NeuralNetworkPreprocessing.OneOf_Preprocessor, rhs: CoreML_Specification_NeuralNetworkPreprocessing.OneOf_Preprocessor) -> Bool {
      switch (lhs, rhs) {
      case (.scaler(let l), .scaler(let r)): return l == r
      case (.meanImage(let l), .meanImage(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A rectified linear unit (ReLU) activation function.
///
/// This function has the following formula:
///
/// .. math::
///     f(x) = \text{max}(0, x)
struct CoreML_Specification_ActivationReLU {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A leaky rectified linear unit (ReLU) activation function.
///
/// This function has the following formula:
///
/// .. math::
///     f(x) = \begin{cases}
///             x      & \text{if } x \geq 0 \\
///             \alpha x & \text{if } x < 0
///            \end{cases}
struct CoreML_Specification_ActivationLeakyReLU {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///negative slope value for leakyReLU
  var alpha: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A hyperbolic tangent activation function.
///
/// This function has the following formula:
///
/// .. math::
///     f(x) = \dfrac{1 - e^{-2x}}{1 + e^{-2x}}
struct CoreML_Specification_ActivationTanh {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A scaled hyperbolic tangent activation function.
///
/// This function has the following formula:
///
/// .. math::
///     f(x) = \alpha \tanh(\beta x)
struct CoreML_Specification_ActivationScaledTanh {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var alpha: Float = 0

  var beta: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A sigmoid activation function.
///
/// This function has the following formula:
///
/// .. math::
///     f(x) = \dfrac{1}{1 + e^{-x}}
struct CoreML_Specification_ActivationSigmoid {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A linear activation function.
///
/// This function has the following formula:
///
/// .. math::
///     f(x) = \alpha x + \beta
struct CoreML_Specification_ActivationLinear {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var alpha: Float = 0

  var beta: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A hard sigmoid activation function.
///
/// This function has the following formula:
///
/// .. math::
///     f(x) = \text{min}(\text{max}(\alpha x + \beta, 0), 1)
struct CoreML_Specification_ActivationSigmoidHard {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var alpha: Float = 0

  var beta: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A parameterized rectified linear unit (PReLU) activation function,
/// which takes ``[C]`` or ``[C,H,W]`` as an input and
/// applies different parameters in each channel dimension
/// (shared across the ``H`` and ``W`` components).
///
/// This function has the following formula:
///
/// .. math::
///    f(x_i) = \begin{cases}
///                 x_i          & \text{if } x_i \geq 0 \\
///                 \alpha_i x_i & \text{if } x_i < 0
///             \end{cases} \;,\;i=1,...,C
struct CoreML_Specification_ActivationPReLU {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// parameter of length C or 1.
  /// If length is 1, same value is used for all channels
  var alpha: CoreML_Specification_WeightParams {
    get {return _storage._alpha ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._alpha = newValue}
  }
  /// Returns true if `alpha` has been explicitly set.
  var hasAlpha: Bool {return _storage._alpha != nil}
  /// Clears the value of `alpha`. Subsequent reads from it will return its default value.
  mutating func clearAlpha() {_uniqueStorage()._alpha = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// An exponential linear unit (ELU) activation function.
///
/// This function has the following formula:
///
/// .. math::
///     f(x) = \begin{cases}
///             x              & \text{if } x \geq 0 \\
///             \alpha (e^x - 1) & \text{if } x < 0
///            \end{cases}
struct CoreML_Specification_ActivationELU {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var alpha: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A thresholded rectified linear unit (ReLU) activation function.
///
/// This function has the following formula:
///
/// .. math::
///     f(x) = \begin{cases}
///             x & \text{if } x \geq \alpha \\
///             0 & \text{if } x < \alpha
///            \end{cases}
struct CoreML_Specification_ActivationThresholdedReLU {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var alpha: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A softsign activation function.
///
/// This function has the following formula:
///
/// .. math::
///     f(x) = \dfrac{x}{1 + |x|}
struct CoreML_Specification_ActivationSoftsign {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A softplus activation function.
///
/// This function has the following formula:
///
/// .. math::
///     f(x) = \text{log}(1 + e^x)
struct CoreML_Specification_ActivationSoftplus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A parametric softplus activation function,
/// which takes ``[C]`` or ``[C,H,W]`` as an input and
/// applies different parameters in each channel dimension
/// (shared across the ``H`` and ``W`` components).
///
/// This function has the following formula:
///
/// .. math::
///     f(x_i) = \alpha_i \text{log}(1 + e^{\beta_i x_i}) \;,\;i=1,...,C
struct CoreML_Specification_ActivationParametricSoftplus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If length is 1, same value is used for all channels
  var alpha: CoreML_Specification_WeightParams {
    get {return _storage._alpha ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._alpha = newValue}
  }
  /// Returns true if `alpha` has been explicitly set.
  var hasAlpha: Bool {return _storage._alpha != nil}
  /// Clears the value of `alpha`. Subsequent reads from it will return its default value.
  mutating func clearAlpha() {_uniqueStorage()._alpha = nil}

  ///parameter of length C or 1
  var beta: CoreML_Specification_WeightParams {
    get {return _storage._beta ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._beta = newValue}
  }
  /// Returns true if `beta` has been explicitly set.
  var hasBeta: Bool {return _storage._beta != nil}
  /// Clears the value of `beta`. Subsequent reads from it will return its default value.
  mutating func clearBeta() {_uniqueStorage()._beta = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct CoreML_Specification_ActivationParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nonlinearityType: OneOf_NonlinearityType? {
    get {return _storage._nonlinearityType}
    set {_uniqueStorage()._nonlinearityType = newValue}
  }

  var linear: CoreML_Specification_ActivationLinear {
    get {
      if case .linear(let v)? = _storage._nonlinearityType {return v}
      return CoreML_Specification_ActivationLinear()
    }
    set {_uniqueStorage()._nonlinearityType = .linear(newValue)}
  }

  var reLu: CoreML_Specification_ActivationReLU {
    get {
      if case .reLu(let v)? = _storage._nonlinearityType {return v}
      return CoreML_Specification_ActivationReLU()
    }
    set {_uniqueStorage()._nonlinearityType = .reLu(newValue)}
  }

  var leakyReLu: CoreML_Specification_ActivationLeakyReLU {
    get {
      if case .leakyReLu(let v)? = _storage._nonlinearityType {return v}
      return CoreML_Specification_ActivationLeakyReLU()
    }
    set {_uniqueStorage()._nonlinearityType = .leakyReLu(newValue)}
  }

  var thresholdedReLu: CoreML_Specification_ActivationThresholdedReLU {
    get {
      if case .thresholdedReLu(let v)? = _storage._nonlinearityType {return v}
      return CoreML_Specification_ActivationThresholdedReLU()
    }
    set {_uniqueStorage()._nonlinearityType = .thresholdedReLu(newValue)}
  }

  var preLu: CoreML_Specification_ActivationPReLU {
    get {
      if case .preLu(let v)? = _storage._nonlinearityType {return v}
      return CoreML_Specification_ActivationPReLU()
    }
    set {_uniqueStorage()._nonlinearityType = .preLu(newValue)}
  }

  var tanh: CoreML_Specification_ActivationTanh {
    get {
      if case .tanh(let v)? = _storage._nonlinearityType {return v}
      return CoreML_Specification_ActivationTanh()
    }
    set {_uniqueStorage()._nonlinearityType = .tanh(newValue)}
  }

  var scaledTanh: CoreML_Specification_ActivationScaledTanh {
    get {
      if case .scaledTanh(let v)? = _storage._nonlinearityType {return v}
      return CoreML_Specification_ActivationScaledTanh()
    }
    set {_uniqueStorage()._nonlinearityType = .scaledTanh(newValue)}
  }

  var sigmoid: CoreML_Specification_ActivationSigmoid {
    get {
      if case .sigmoid(let v)? = _storage._nonlinearityType {return v}
      return CoreML_Specification_ActivationSigmoid()
    }
    set {_uniqueStorage()._nonlinearityType = .sigmoid(newValue)}
  }

  var sigmoidHard: CoreML_Specification_ActivationSigmoidHard {
    get {
      if case .sigmoidHard(let v)? = _storage._nonlinearityType {return v}
      return CoreML_Specification_ActivationSigmoidHard()
    }
    set {_uniqueStorage()._nonlinearityType = .sigmoidHard(newValue)}
  }

  var elu: CoreML_Specification_ActivationELU {
    get {
      if case .elu(let v)? = _storage._nonlinearityType {return v}
      return CoreML_Specification_ActivationELU()
    }
    set {_uniqueStorage()._nonlinearityType = .elu(newValue)}
  }

  var softsign: CoreML_Specification_ActivationSoftsign {
    get {
      if case .softsign(let v)? = _storage._nonlinearityType {return v}
      return CoreML_Specification_ActivationSoftsign()
    }
    set {_uniqueStorage()._nonlinearityType = .softsign(newValue)}
  }

  var softplus: CoreML_Specification_ActivationSoftplus {
    get {
      if case .softplus(let v)? = _storage._nonlinearityType {return v}
      return CoreML_Specification_ActivationSoftplus()
    }
    set {_uniqueStorage()._nonlinearityType = .softplus(newValue)}
  }

  var parametricSoftplus: CoreML_Specification_ActivationParametricSoftplus {
    get {
      if case .parametricSoftplus(let v)? = _storage._nonlinearityType {return v}
      return CoreML_Specification_ActivationParametricSoftplus()
    }
    set {_uniqueStorage()._nonlinearityType = .parametricSoftplus(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_NonlinearityType: Equatable {
    case linear(CoreML_Specification_ActivationLinear)
    case reLu(CoreML_Specification_ActivationReLU)
    case leakyReLu(CoreML_Specification_ActivationLeakyReLU)
    case thresholdedReLu(CoreML_Specification_ActivationThresholdedReLU)
    case preLu(CoreML_Specification_ActivationPReLU)
    case tanh(CoreML_Specification_ActivationTanh)
    case scaledTanh(CoreML_Specification_ActivationScaledTanh)
    case sigmoid(CoreML_Specification_ActivationSigmoid)
    case sigmoidHard(CoreML_Specification_ActivationSigmoidHard)
    case elu(CoreML_Specification_ActivationELU)
    case softsign(CoreML_Specification_ActivationSoftsign)
    case softplus(CoreML_Specification_ActivationSoftplus)
    case parametricSoftplus(CoreML_Specification_ActivationParametricSoftplus)

  #if !swift(>=4.1)
    static func ==(lhs: CoreML_Specification_ActivationParams.OneOf_NonlinearityType, rhs: CoreML_Specification_ActivationParams.OneOf_NonlinearityType) -> Bool {
      switch (lhs, rhs) {
      case (.linear(let l), .linear(let r)): return l == r
      case (.reLu(let l), .reLu(let r)): return l == r
      case (.leakyReLu(let l), .leakyReLu(let r)): return l == r
      case (.thresholdedReLu(let l), .thresholdedReLu(let r)): return l == r
      case (.preLu(let l), .preLu(let r)): return l == r
      case (.tanh(let l), .tanh(let r)): return l == r
      case (.scaledTanh(let l), .scaledTanh(let r)): return l == r
      case (.sigmoid(let l), .sigmoid(let r)): return l == r
      case (.sigmoidHard(let l), .sigmoidHard(let r)): return l == r
      case (.elu(let l), .elu(let r)): return l == r
      case (.softsign(let l), .softsign(let r)): return l == r
      case (.softplus(let l), .softplus(let r)): return l == r
      case (.parametricSoftplus(let l), .parametricSoftplus(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A single neural network layer.
struct CoreML_Specification_NeuralNetworkLayer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///descriptive name of the layer
  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var input: [String] {
    get {return _storage._input}
    set {_uniqueStorage()._input = newValue}
  }

  var output: [String] {
    get {return _storage._output}
    set {_uniqueStorage()._output = newValue}
  }

  var layer: OneOf_Layer? {
    get {return _storage._layer}
    set {_uniqueStorage()._layer = newValue}
  }

  /// start at 100 here
  var convolution: CoreML_Specification_ConvolutionLayerParams {
    get {
      if case .convolution(let v)? = _storage._layer {return v}
      return CoreML_Specification_ConvolutionLayerParams()
    }
    set {_uniqueStorage()._layer = .convolution(newValue)}
  }

  var pooling: CoreML_Specification_PoolingLayerParams {
    get {
      if case .pooling(let v)? = _storage._layer {return v}
      return CoreML_Specification_PoolingLayerParams()
    }
    set {_uniqueStorage()._layer = .pooling(newValue)}
  }

  var activation: CoreML_Specification_ActivationParams {
    get {
      if case .activation(let v)? = _storage._layer {return v}
      return CoreML_Specification_ActivationParams()
    }
    set {_uniqueStorage()._layer = .activation(newValue)}
  }

  var innerProduct: CoreML_Specification_InnerProductLayerParams {
    get {
      if case .innerProduct(let v)? = _storage._layer {return v}
      return CoreML_Specification_InnerProductLayerParams()
    }
    set {_uniqueStorage()._layer = .innerProduct(newValue)}
  }

  var embedding: CoreML_Specification_EmbeddingLayerParams {
    get {
      if case .embedding(let v)? = _storage._layer {return v}
      return CoreML_Specification_EmbeddingLayerParams()
    }
    set {_uniqueStorage()._layer = .embedding(newValue)}
  }

  ///normalization related layers
  var batchnorm: CoreML_Specification_BatchnormLayerParams {
    get {
      if case .batchnorm(let v)? = _storage._layer {return v}
      return CoreML_Specification_BatchnormLayerParams()
    }
    set {_uniqueStorage()._layer = .batchnorm(newValue)}
  }

  var mvn: CoreML_Specification_MeanVarianceNormalizeLayerParams {
    get {
      if case .mvn(let v)? = _storage._layer {return v}
      return CoreML_Specification_MeanVarianceNormalizeLayerParams()
    }
    set {_uniqueStorage()._layer = .mvn(newValue)}
  }

  var l2Normalize: CoreML_Specification_L2NormalizeLayerParams {
    get {
      if case .l2Normalize(let v)? = _storage._layer {return v}
      return CoreML_Specification_L2NormalizeLayerParams()
    }
    set {_uniqueStorage()._layer = .l2Normalize(newValue)}
  }

  var softmax: CoreML_Specification_SoftmaxLayerParams {
    get {
      if case .softmax(let v)? = _storage._layer {return v}
      return CoreML_Specification_SoftmaxLayerParams()
    }
    set {_uniqueStorage()._layer = .softmax(newValue)}
  }

  var lrn: CoreML_Specification_LRNLayerParams {
    get {
      if case .lrn(let v)? = _storage._layer {return v}
      return CoreML_Specification_LRNLayerParams()
    }
    set {_uniqueStorage()._layer = .lrn(newValue)}
  }

  var crop: CoreML_Specification_CropLayerParams {
    get {
      if case .crop(let v)? = _storage._layer {return v}
      return CoreML_Specification_CropLayerParams()
    }
    set {_uniqueStorage()._layer = .crop(newValue)}
  }

  var padding: CoreML_Specification_PaddingLayerParams {
    get {
      if case .padding(let v)? = _storage._layer {return v}
      return CoreML_Specification_PaddingLayerParams()
    }
    set {_uniqueStorage()._layer = .padding(newValue)}
  }

  var upsample: CoreML_Specification_UpsampleLayerParams {
    get {
      if case .upsample(let v)? = _storage._layer {return v}
      return CoreML_Specification_UpsampleLayerParams()
    }
    set {_uniqueStorage()._layer = .upsample(newValue)}
  }

  var resizeBilinear: CoreML_Specification_ResizeBilinearLayerParams {
    get {
      if case .resizeBilinear(let v)? = _storage._layer {return v}
      return CoreML_Specification_ResizeBilinearLayerParams()
    }
    set {_uniqueStorage()._layer = .resizeBilinear(newValue)}
  }

  var cropResize: CoreML_Specification_CropResizeLayerParams {
    get {
      if case .cropResize(let v)? = _storage._layer {return v}
      return CoreML_Specification_CropResizeLayerParams()
    }
    set {_uniqueStorage()._layer = .cropResize(newValue)}
  }

  var unary: CoreML_Specification_UnaryFunctionLayerParams {
    get {
      if case .unary(let v)? = _storage._layer {return v}
      return CoreML_Specification_UnaryFunctionLayerParams()
    }
    set {_uniqueStorage()._layer = .unary(newValue)}
  }

  ///elementwise operations
  var add: CoreML_Specification_AddLayerParams {
    get {
      if case .add(let v)? = _storage._layer {return v}
      return CoreML_Specification_AddLayerParams()
    }
    set {_uniqueStorage()._layer = .add(newValue)}
  }

  var multiply: CoreML_Specification_MultiplyLayerParams {
    get {
      if case .multiply(let v)? = _storage._layer {return v}
      return CoreML_Specification_MultiplyLayerParams()
    }
    set {_uniqueStorage()._layer = .multiply(newValue)}
  }

  var average: CoreML_Specification_AverageLayerParams {
    get {
      if case .average(let v)? = _storage._layer {return v}
      return CoreML_Specification_AverageLayerParams()
    }
    set {_uniqueStorage()._layer = .average(newValue)}
  }

  var scale: CoreML_Specification_ScaleLayerParams {
    get {
      if case .scale(let v)? = _storage._layer {return v}
      return CoreML_Specification_ScaleLayerParams()
    }
    set {_uniqueStorage()._layer = .scale(newValue)}
  }

  var bias: CoreML_Specification_BiasLayerParams {
    get {
      if case .bias(let v)? = _storage._layer {return v}
      return CoreML_Specification_BiasLayerParams()
    }
    set {_uniqueStorage()._layer = .bias(newValue)}
  }

  var max: CoreML_Specification_MaxLayerParams {
    get {
      if case .max(let v)? = _storage._layer {return v}
      return CoreML_Specification_MaxLayerParams()
    }
    set {_uniqueStorage()._layer = .max(newValue)}
  }

  var min: CoreML_Specification_MinLayerParams {
    get {
      if case .min(let v)? = _storage._layer {return v}
      return CoreML_Specification_MinLayerParams()
    }
    set {_uniqueStorage()._layer = .min(newValue)}
  }

  var dot: CoreML_Specification_DotProductLayerParams {
    get {
      if case .dot(let v)? = _storage._layer {return v}
      return CoreML_Specification_DotProductLayerParams()
    }
    set {_uniqueStorage()._layer = .dot(newValue)}
  }

  var reduce: CoreML_Specification_ReduceLayerParams {
    get {
      if case .reduce(let v)? = _storage._layer {return v}
      return CoreML_Specification_ReduceLayerParams()
    }
    set {_uniqueStorage()._layer = .reduce(newValue)}
  }

  var loadConstant: CoreML_Specification_LoadConstantLayerParams {
    get {
      if case .loadConstant(let v)? = _storage._layer {return v}
      return CoreML_Specification_LoadConstantLayerParams()
    }
    set {_uniqueStorage()._layer = .loadConstant(newValue)}
  }

  ///data reorganization
  var reshape: CoreML_Specification_ReshapeLayerParams {
    get {
      if case .reshape(let v)? = _storage._layer {return v}
      return CoreML_Specification_ReshapeLayerParams()
    }
    set {_uniqueStorage()._layer = .reshape(newValue)}
  }

  var flatten: CoreML_Specification_FlattenLayerParams {
    get {
      if case .flatten(let v)? = _storage._layer {return v}
      return CoreML_Specification_FlattenLayerParams()
    }
    set {_uniqueStorage()._layer = .flatten(newValue)}
  }

  var permute: CoreML_Specification_PermuteLayerParams {
    get {
      if case .permute(let v)? = _storage._layer {return v}
      return CoreML_Specification_PermuteLayerParams()
    }
    set {_uniqueStorage()._layer = .permute(newValue)}
  }

  var concat: CoreML_Specification_ConcatLayerParams {
    get {
      if case .concat(let v)? = _storage._layer {return v}
      return CoreML_Specification_ConcatLayerParams()
    }
    set {_uniqueStorage()._layer = .concat(newValue)}
  }

  var split: CoreML_Specification_SplitLayerParams {
    get {
      if case .split(let v)? = _storage._layer {return v}
      return CoreML_Specification_SplitLayerParams()
    }
    set {_uniqueStorage()._layer = .split(newValue)}
  }

  var sequenceRepeat: CoreML_Specification_SequenceRepeatLayerParams {
    get {
      if case .sequenceRepeat(let v)? = _storage._layer {return v}
      return CoreML_Specification_SequenceRepeatLayerParams()
    }
    set {_uniqueStorage()._layer = .sequenceRepeat(newValue)}
  }

  var reorganizeData: CoreML_Specification_ReorganizeDataLayerParams {
    get {
      if case .reorganizeData(let v)? = _storage._layer {return v}
      return CoreML_Specification_ReorganizeDataLayerParams()
    }
    set {_uniqueStorage()._layer = .reorganizeData(newValue)}
  }

  var slice: CoreML_Specification_SliceLayerParams {
    get {
      if case .slice(let v)? = _storage._layer {return v}
      return CoreML_Specification_SliceLayerParams()
    }
    set {_uniqueStorage()._layer = .slice(newValue)}
  }

  ///Recurrent Layers
  var simpleRecurrent: CoreML_Specification_SimpleRecurrentLayerParams {
    get {
      if case .simpleRecurrent(let v)? = _storage._layer {return v}
      return CoreML_Specification_SimpleRecurrentLayerParams()
    }
    set {_uniqueStorage()._layer = .simpleRecurrent(newValue)}
  }

  var gru: CoreML_Specification_GRULayerParams {
    get {
      if case .gru(let v)? = _storage._layer {return v}
      return CoreML_Specification_GRULayerParams()
    }
    set {_uniqueStorage()._layer = .gru(newValue)}
  }

  var uniDirectionalLstm: CoreML_Specification_UniDirectionalLSTMLayerParams {
    get {
      if case .uniDirectionalLstm(let v)? = _storage._layer {return v}
      return CoreML_Specification_UniDirectionalLSTMLayerParams()
    }
    set {_uniqueStorage()._layer = .uniDirectionalLstm(newValue)}
  }

  var biDirectionalLstm: CoreML_Specification_BiDirectionalLSTMLayerParams {
    get {
      if case .biDirectionalLstm(let v)? = _storage._layer {return v}
      return CoreML_Specification_BiDirectionalLSTMLayerParams()
    }
    set {_uniqueStorage()._layer = .biDirectionalLstm(newValue)}
  }

  /// Custom (user-implemented) Layer
  var custom: CoreML_Specification_CustomLayerParams {
    get {
      if case .custom(let v)? = _storage._layer {return v}
      return CoreML_Specification_CustomLayerParams()
    }
    set {_uniqueStorage()._layer = .custom(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Layer: Equatable {
    /// start at 100 here
    case convolution(CoreML_Specification_ConvolutionLayerParams)
    case pooling(CoreML_Specification_PoolingLayerParams)
    case activation(CoreML_Specification_ActivationParams)
    case innerProduct(CoreML_Specification_InnerProductLayerParams)
    case embedding(CoreML_Specification_EmbeddingLayerParams)
    ///normalization related layers
    case batchnorm(CoreML_Specification_BatchnormLayerParams)
    case mvn(CoreML_Specification_MeanVarianceNormalizeLayerParams)
    case l2Normalize(CoreML_Specification_L2NormalizeLayerParams)
    case softmax(CoreML_Specification_SoftmaxLayerParams)
    case lrn(CoreML_Specification_LRNLayerParams)
    case crop(CoreML_Specification_CropLayerParams)
    case padding(CoreML_Specification_PaddingLayerParams)
    case upsample(CoreML_Specification_UpsampleLayerParams)
    case resizeBilinear(CoreML_Specification_ResizeBilinearLayerParams)
    case cropResize(CoreML_Specification_CropResizeLayerParams)
    case unary(CoreML_Specification_UnaryFunctionLayerParams)
    ///elementwise operations
    case add(CoreML_Specification_AddLayerParams)
    case multiply(CoreML_Specification_MultiplyLayerParams)
    case average(CoreML_Specification_AverageLayerParams)
    case scale(CoreML_Specification_ScaleLayerParams)
    case bias(CoreML_Specification_BiasLayerParams)
    case max(CoreML_Specification_MaxLayerParams)
    case min(CoreML_Specification_MinLayerParams)
    case dot(CoreML_Specification_DotProductLayerParams)
    case reduce(CoreML_Specification_ReduceLayerParams)
    case loadConstant(CoreML_Specification_LoadConstantLayerParams)
    ///data reorganization
    case reshape(CoreML_Specification_ReshapeLayerParams)
    case flatten(CoreML_Specification_FlattenLayerParams)
    case permute(CoreML_Specification_PermuteLayerParams)
    case concat(CoreML_Specification_ConcatLayerParams)
    case split(CoreML_Specification_SplitLayerParams)
    case sequenceRepeat(CoreML_Specification_SequenceRepeatLayerParams)
    case reorganizeData(CoreML_Specification_ReorganizeDataLayerParams)
    case slice(CoreML_Specification_SliceLayerParams)
    ///Recurrent Layers
    case simpleRecurrent(CoreML_Specification_SimpleRecurrentLayerParams)
    case gru(CoreML_Specification_GRULayerParams)
    case uniDirectionalLstm(CoreML_Specification_UniDirectionalLSTMLayerParams)
    case biDirectionalLstm(CoreML_Specification_BiDirectionalLSTMLayerParams)
    /// Custom (user-implemented) Layer
    case custom(CoreML_Specification_CustomLayerParams)

  #if !swift(>=4.1)
    static func ==(lhs: CoreML_Specification_NeuralNetworkLayer.OneOf_Layer, rhs: CoreML_Specification_NeuralNetworkLayer.OneOf_Layer) -> Bool {
      switch (lhs, rhs) {
      case (.convolution(let l), .convolution(let r)): return l == r
      case (.pooling(let l), .pooling(let r)): return l == r
      case (.activation(let l), .activation(let r)): return l == r
      case (.innerProduct(let l), .innerProduct(let r)): return l == r
      case (.embedding(let l), .embedding(let r)): return l == r
      case (.batchnorm(let l), .batchnorm(let r)): return l == r
      case (.mvn(let l), .mvn(let r)): return l == r
      case (.l2Normalize(let l), .l2Normalize(let r)): return l == r
      case (.softmax(let l), .softmax(let r)): return l == r
      case (.lrn(let l), .lrn(let r)): return l == r
      case (.crop(let l), .crop(let r)): return l == r
      case (.padding(let l), .padding(let r)): return l == r
      case (.upsample(let l), .upsample(let r)): return l == r
      case (.resizeBilinear(let l), .resizeBilinear(let r)): return l == r
      case (.cropResize(let l), .cropResize(let r)): return l == r
      case (.unary(let l), .unary(let r)): return l == r
      case (.add(let l), .add(let r)): return l == r
      case (.multiply(let l), .multiply(let r)): return l == r
      case (.average(let l), .average(let r)): return l == r
      case (.scale(let l), .scale(let r)): return l == r
      case (.bias(let l), .bias(let r)): return l == r
      case (.max(let l), .max(let r)): return l == r
      case (.min(let l), .min(let r)): return l == r
      case (.dot(let l), .dot(let r)): return l == r
      case (.reduce(let l), .reduce(let r)): return l == r
      case (.loadConstant(let l), .loadConstant(let r)): return l == r
      case (.reshape(let l), .reshape(let r)): return l == r
      case (.flatten(let l), .flatten(let r)): return l == r
      case (.permute(let l), .permute(let r)): return l == r
      case (.concat(let l), .concat(let r)): return l == r
      case (.split(let l), .split(let r)): return l == r
      case (.sequenceRepeat(let l), .sequenceRepeat(let r)): return l == r
      case (.reorganizeData(let l), .reorganizeData(let r)): return l == r
      case (.slice(let l), .slice(let r)): return l == r
      case (.simpleRecurrent(let l), .simpleRecurrent(let r)): return l == r
      case (.gru(let l), .gru(let r)): return l == r
      case (.uniDirectionalLstm(let l), .uniDirectionalLstm(let r)): return l == r
      case (.biDirectionalLstm(let l), .biDirectionalLstm(let r)): return l == r
      case (.custom(let l), .custom(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// Specifies the amount of spatial border to be either padded or cropped.
///
/// For padding:
///
/// .. code::
///
///     H_out = borderAmounts[0].startEdgeSize + H_in + borderAmounts[0].endEdgeSize
///     W_out = borderAmounts[1].startEdgeSize + W_in + borderAmounts[1].endEdgeSize
///
///     topPaddingAmount == Height startEdgeSize
///     bottomPaddingAmount == Height endEdgeSize
///     leftPaddingAmount == Width startEdgeSize
///     rightPaddingAmount == Width endEdgeSize
///
/// For cropping:
///
/// .. code::
///
///     H_out = (-borderAmounts[0].startEdgeSize) + H_in + (-borderAmounts[0].endEdgeSize)
///     W_out = (-borderAmounts[1].startEdgeSize) + W_in + (-borderAmounts[1].endEdgeSize)
///
///     topCropAmount == Height startEdgeSize
///     bottomCropAmount == Height endEdgeSize
///     leftCropAmount == Width startEdgeSize
///     rightCropAmount == Width endEdgeSize
struct CoreML_Specification_BorderAmounts {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The border amounts.
  /// This must be length 2 in the order ``[H, W]``.
  var borderAmounts: [CoreML_Specification_BorderAmounts.EdgeSizes] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct EdgeSizes {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///*
    /// The amount to be padded or cropped from the beginning.
    var startEdgeSize: UInt64 = 0

    ///*
    /// The amount to be padded or cropped from the end.
    var endEdgeSize: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

///*
/// Specifies the type of padding to be used with Convolution/Deconvolution and Pooling layers.
/// After padding, input spatial shape: ``[H_in, W_in]``, gets modified to the
/// output spatial shape ``[H_out, W_out]``.
///
/// .. code::
///
///      topPaddingAmount == Height startEdgeSize == borderAmounts[0].startEdgeSize
///      bottomPaddingAmount == Height endEdgeSize == borderAmounts[0].endEdgeSize
///      leftPaddingAmount == Width startEdgeSize == borderAmounts[1].startEdgeSize
///      rightPaddingAmount == Width endEdgeSize == borderAmounts[1].endEdgeSize
///
/// With Convolution or Pooling:
///
/// .. code::
///
///    H_out = int_division_round_down((H_in + topPaddingAmount + bottomPaddingAmount - KernelSize[0]),stride[0]) + 1
///
/// which is same as:
///
/// .. code::
///
///    H_out = int_division_round_up((H_in + topPaddingAmount + bottomPaddingAmount - KernelSize[0] + 1),stride[0])
///
/// With Deconvolution:
///
/// .. code::
///
///    H_out = (H_in-1) * stride[0] + kernelSize[0] - (topPaddingAmount + bottomPaddingAmount)
///
///
/// The equivalent expressions hold true for ``W_out`` as well.
///
///
/// By default, the values of ``paddingAmounts`` are set to ``0``,
/// which results in a "true" valid padding.
/// If non-zero values are provided for ``paddingAmounts``,
/// "valid" convolution/pooling is performed within the spatially expanded input.
struct CoreML_Specification_ValidPadding {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var paddingAmounts: CoreML_Specification_BorderAmounts {
    get {return _storage._paddingAmounts ?? CoreML_Specification_BorderAmounts()}
    set {_uniqueStorage()._paddingAmounts = newValue}
  }
  /// Returns true if `paddingAmounts` has been explicitly set.
  var hasPaddingAmounts: Bool {return _storage._paddingAmounts != nil}
  /// Clears the value of `paddingAmounts`. Subsequent reads from it will return its default value.
  mutating func clearPaddingAmounts() {_uniqueStorage()._paddingAmounts = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// Specifies the type of padding to be used with Convolution/Deconvolution and pooling layers.
/// After padding, input spatial shape: ``[H_in, W_in]``, gets modified to the
/// output spatial shape ``[H_out, W_out]``.
/// With Convolution or pooling:
///
/// .. code::
///
///      H_out = int_division_round_up(H_in,stride[0])
///      W_out = int_division_round_up(W_in,stride[1])
///
/// This is achieved by using the following padding amounts:
///
/// .. code::
///
///     totalPaddingHeight = max(0,(H_out-1) * stride[0] + KernelSize[0] - Hin)
///     totalPaddingWidth = max(0,(W_out-1) * stride[1] + KernelSize[1] - Win)
///
/// There are two modes of asymmetry:
/// ``BOTTOM_RIGHT_HEAVY``, and ``TOP_LEFT_HEAVY``.
///
/// If the mode is ``BOTTOM_RIGHT_HEAVY``:
///
/// .. code::
///
///     topPaddingAmount = floor(totalPaddingHeight / 2)
///     bottomPaddingAmount = totalPaddingHeight - topPaddingAmount
///     leftPaddingAmount = floor(totalPaddingWidth / 2)
///     rightPaddingAmount = totalPaddingWidth - leftPaddingAmount
///
/// If the mode is ``TOP_LEFT_HEAVY``:
///
/// .. code::
///
///     bottomPaddingAmount = floor(totalPaddingHeight / 2)
///     topPaddingAmount = totalPaddingHeight - bottomPaddingAmount
///     rightPaddingAmount = floor(totalPaddingWidth / 2)
///     leftPaddingAmount = totalPaddingWidth - rightPaddingAmount
///
///
/// With Deconvolution:
///
/// .. code::
///
///    H_out = H_in * stride[0]
///    W_out = W_in * stride[1]
struct CoreML_Specification_SamePadding {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var asymmetryMode: CoreML_Specification_SamePadding.SamePaddingMode = .bottomRightHeavy

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum SamePaddingMode: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case bottomRightHeavy // = 0
    case topLeftHeavy // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .bottomRightHeavy
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .bottomRightHeavy
      case 1: self = .topLeftHeavy
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .bottomRightHeavy: return 0
      case .topLeftHeavy: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension CoreML_Specification_SamePadding.SamePaddingMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [CoreML_Specification_SamePadding.SamePaddingMode] = [
    .bottomRightHeavy,
    .topLeftHeavy,
  ]
}

#endif  // swift(>=4.2)

///*
/// Specifies how grid points are sampled from an interval. 
/// Without the loss of generality, assume the interval to be [0, X-1] from which N points are to be sampled.
/// Here X may correspond to an input image's height or width. 
/// All the methods can be expressed in terms of numpy's linspace function, along with the constraint that grid points have to lie in the interval [0, X-1].
/// Note: numpy.linspace(start = start, end = end, num = N, endpoint = True) corresponds to sampling 
/// N points uniformly from the interval [start, end], endpoints included. 
/// The methods vary in how the ``start`` and ``end`` values are computed.  
struct CoreML_Specification_SamplingMode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var samplingMethod: CoreML_Specification_SamplingMode.Method = .strictAlignEndpointsMode

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Method: SwiftProtobuf.Enum {
    typealias RawValue = Int

    ///*
    /// start = 0, end = X-1
    /// grid points = numpy.linspace(start, end)
    case strictAlignEndpointsMode // = 0

    ///* 
    /// if N == 1: start = end = (X-1)/2
    /// otherwise, start = 0, end = X-1
    /// grid points = numpy.linspace(start, end)
    case alignEndpointsMode // = 1

    ///*
    /// start = 0, end = X - X/N
    /// grid points = min(X-1, numpy.linspace(start, end))
    /// This is same as the mode used in the upsample layer in this specification, when used with bilinear interpolation. In that case N/X = upsample ratio.
    case upsampleMode // = 2

    ///*
    /// spacing = max(1, X-1)/N
    /// start = 0.5 * spacing
    /// end = start + (N-1) * spacing
    /// grid points = min(X-1, numpy.linspace(start, end))
    case roiAlignMode // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .strictAlignEndpointsMode
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .strictAlignEndpointsMode
      case 1: self = .alignEndpointsMode
      case 2: self = .upsampleMode
      case 3: self = .roiAlignMode
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .strictAlignEndpointsMode: return 0
      case .alignEndpointsMode: return 1
      case .upsampleMode: return 2
      case .roiAlignMode: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension CoreML_Specification_SamplingMode.Method: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [CoreML_Specification_SamplingMode.Method] = [
    .strictAlignEndpointsMode,
    .alignEndpointsMode,
    .upsampleMode,
    .roiAlignMode,
  ]
}

#endif  // swift(>=4.2)

///*
/// Specifies the convention used to specify four bounding box coordinates for an image of size (Height, Width).
/// The (0,0) coordinate corresponds to the top-left corner of the image. 
struct CoreML_Specification_BoxCoordinatesMode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var boxMode: CoreML_Specification_BoxCoordinatesMode.Coordinates = .cornersHeightFirst

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Coordinates: SwiftProtobuf.Enum {
    typealias RawValue = Int

    ///*
    /// [h_start, w_start, h_end, w_end]
    case cornersHeightFirst // = 0

    ///*
    /// [w_start, h_start, w_end, h_end]
    case cornersWidthFirst // = 1

    ///*
    /// [h_center, w_center, box_height, box_width]
    case centerSizeHeightFirst // = 2

    ///*
    /// [w_center, h_center, box_width, box_height]
    case centerSizeWidthFirst // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .cornersHeightFirst
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .cornersHeightFirst
      case 1: self = .cornersWidthFirst
      case 2: self = .centerSizeHeightFirst
      case 3: self = .centerSizeWidthFirst
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .cornersHeightFirst: return 0
      case .cornersWidthFirst: return 1
      case .centerSizeHeightFirst: return 2
      case .centerSizeWidthFirst: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension CoreML_Specification_BoxCoordinatesMode.Coordinates: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [CoreML_Specification_BoxCoordinatesMode.Coordinates] = [
    .cornersHeightFirst,
    .cornersWidthFirst,
    .centerSizeHeightFirst,
    .centerSizeWidthFirst,
  ]
}

#endif  // swift(>=4.2)

///*
/// Weights for layer parameters.
/// Weights are stored as repeated floating point numbers
/// using row-major ordering
/// and can represent 1-, 2-, 3-, or 4-dimensional data.
struct CoreML_Specification_WeightParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// Values specified in single / float / FP32 precision.
  var floatValue: [Float] {
    get {return _storage._floatValue}
    set {_uniqueStorage()._floatValue = newValue}
  }

  ///*
  /// Values in 16-bit half precision floating point.
  var float16Value: Data {
    get {return _storage._float16Value}
    set {_uniqueStorage()._float16Value = newValue}
  }

  ///*
  /// Raw value specification for custom layers and quantized lower precisions.
  var rawValue: Data {
    get {return _storage._rawValue}
    set {_uniqueStorage()._rawValue = newValue}
  }

  ///*
  /// Quantization related parameters.
  var quantization: CoreML_Specification_QuantizationParams {
    get {return _storage._quantization ?? CoreML_Specification_QuantizationParams()}
    set {_uniqueStorage()._quantization = newValue}
  }
  /// Returns true if `quantization` has been explicitly set.
  var hasQuantization: Bool {return _storage._quantization != nil}
  /// Clears the value of `quantization`. Subsequent reads from it will return its default value.
  mutating func clearQuantization() {_uniqueStorage()._quantization = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// Quantization parameters.
struct CoreML_Specification_QuantizationParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var numberOfBits: UInt64 {
    get {return _storage._numberOfBits}
    set {_uniqueStorage()._numberOfBits = newValue}
  }

  var quantizationType: OneOf_QuantizationType? {
    get {return _storage._quantizationType}
    set {_uniqueStorage()._quantizationType = newValue}
  }

  var linearQuantization: CoreML_Specification_LinearQuantizationParams {
    get {
      if case .linearQuantization(let v)? = _storage._quantizationType {return v}
      return CoreML_Specification_LinearQuantizationParams()
    }
    set {_uniqueStorage()._quantizationType = .linearQuantization(newValue)}
  }

  var lookupTableQuantization: CoreML_Specification_LookUpTableQuantizationParams {
    get {
      if case .lookupTableQuantization(let v)? = _storage._quantizationType {return v}
      return CoreML_Specification_LookUpTableQuantizationParams()
    }
    set {_uniqueStorage()._quantizationType = .lookupTableQuantization(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_QuantizationType: Equatable {
    case linearQuantization(CoreML_Specification_LinearQuantizationParams)
    case lookupTableQuantization(CoreML_Specification_LookUpTableQuantizationParams)

  #if !swift(>=4.1)
    static func ==(lhs: CoreML_Specification_QuantizationParams.OneOf_QuantizationType, rhs: CoreML_Specification_QuantizationParams.OneOf_QuantizationType) -> Bool {
      switch (lhs, rhs) {
      case (.linearQuantization(let l), .linearQuantization(let r)): return l == r
      case (.lookupTableQuantization(let l), .lookupTableQuantization(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct CoreML_Specification_LinearQuantizationParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// Stores scale and bias values corresponding to the quantized weights.
  /// Must be an array of 1 element, or an array of C elements, where C
  /// is number of output channels. For recurrent layers it is equal to
  /// the output vector size.
  var scale: [Float] = []

  var bias: [Float] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CoreML_Specification_LookUpTableQuantizationParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Stores look-up table quantization values. Must be an array of 
  ///(2^numberOfBits) Elements.
  var floatValue: [Float] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A layer that performs spatial convolution or deconvolution.
///
/// .. code::
///
///      y = ConvolutionLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///  A blob with shape ``[inputChannels,inputHeight,inputWidth]`` or ``[C_in, H_in, W_in]``.
///
/// Output
///  A blob with shape ``[outputChannels,outputHeight,outputWidth]`` or  ``[C_out, H_out, W_out]``.
///
///
/// If ``dilationFactor`` is not 1, effective kernel size is
/// modified as follows:
///
/// .. code::
///
///      KernelSize[0] <-- (kernelSize[0]-1) * dilationFactor[0] + 1
///      KernelSize[1] <-- (kernelSize[1]-1) * dilationFactor[1] + 1
///
/// Type of padding can be ``valid`` or ``same``. Output spatial dimensions depend on the
/// the type of padding. For details, refer to the descriptions of the messages "ValidPadding"
/// and "SamePadding". Padded values are all zeros.
///
/// For Deconvolution, ``ConvolutionPaddingType`` (``valid`` or ``same``) is ignored when ``outputShape`` is set.
struct CoreML_Specification_ConvolutionLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The number of kernels.
  /// Same as ``C_out`` used in the layer description.
  var outputChannels: UInt64 {
    get {return _storage._outputChannels}
    set {_uniqueStorage()._outputChannels = newValue}
  }

  ///*
  /// Channel dimension of the kernels.
  /// Must be equal to ``inputChannels / nGroups``, if isDeconvolution == False
  /// Must be equal to ``inputChannels``, if isDeconvolution == True
  var kernelChannels: UInt64 {
    get {return _storage._kernelChannels}
    set {_uniqueStorage()._kernelChannels = newValue}
  }

  ///*
  /// Group convolution, i.e. weight reuse along channel axis.
  /// Input and kernels are divided into g groups
  /// and convolution / deconvolution is applied within the groups independently.
  /// If not set or 0, it is set to the default value 1.
  var nGroups: UInt64 {
    get {return _storage._nGroups}
    set {_uniqueStorage()._nGroups = newValue}
  }

  ///*
  /// Must be length 2 in the order ``[H, W]``.
  /// If not set, default value ``[3, 3]`` is used.
  var kernelSize: [UInt64] {
    get {return _storage._kernelSize}
    set {_uniqueStorage()._kernelSize = newValue}
  }

  ///*
  /// Must be length 2 in the order ``[H, W]``.
  /// If not set, default value ``[1, 1]`` is used.
  var stride: [UInt64] {
    get {return _storage._stride}
    set {_uniqueStorage()._stride = newValue}
  }

  ///*
  /// Must be length 2 in order ``[H, W]``.
  /// If not set, default value ``[1, 1]`` is used.
  /// It is ignored if ``isDeconvolution == true``.
  var dilationFactor: [UInt64] {
    get {return _storage._dilationFactor}
    set {_uniqueStorage()._dilationFactor = newValue}
  }

  ///*
  /// The type of padding.
  var convolutionPaddingType: OneOf_ConvolutionPaddingType? {
    get {return _storage._convolutionPaddingType}
    set {_uniqueStorage()._convolutionPaddingType = newValue}
  }

  var valid: CoreML_Specification_ValidPadding {
    get {
      if case .valid(let v)? = _storage._convolutionPaddingType {return v}
      return CoreML_Specification_ValidPadding()
    }
    set {_uniqueStorage()._convolutionPaddingType = .valid(newValue)}
  }

  var same: CoreML_Specification_SamePadding {
    get {
      if case .same(let v)? = _storage._convolutionPaddingType {return v}
      return CoreML_Specification_SamePadding()
    }
    set {_uniqueStorage()._convolutionPaddingType = .same(newValue)}
  }

  ///*
  /// Flag to specify whether it is a deconvolution layer.
  var isDeconvolution: Bool {
    get {return _storage._isDeconvolution}
    set {_uniqueStorage()._isDeconvolution = newValue}
  }

  ///*
  /// Flag to specify whether a bias is to be added or not.
  var hasBias_p: Bool {
    get {return _storage._hasBias_p}
    set {_uniqueStorage()._hasBias_p = newValue}
  }

  ///*
  /// Weights associated with this layer.
  /// If convolution (``isDeconvolution == false``), weights have the shape
  /// ``[outputChannels, kernelChannels, kernelHeight, kernelWidth]``, where kernelChannels == inputChannels / nGroups
  /// If deconvolution (``isDeconvolution == true``) weights have the shape
  /// ``[kernelChannels, outputChannels / nGroups, kernelHeight, kernelWidth]``, where kernelChannels == inputChannels
  var weights: CoreML_Specification_WeightParams {
    get {return _storage._weights ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._weights = newValue}
  }
  /// Returns true if `weights` has been explicitly set.
  var hasWeights: Bool {return _storage._weights != nil}
  /// Clears the value of `weights`. Subsequent reads from it will return its default value.
  mutating func clearWeights() {_uniqueStorage()._weights = nil}

  //// Must be of size [outputChannels].
  var bias: CoreML_Specification_WeightParams {
    get {return _storage._bias ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._bias = newValue}
  }
  /// Returns true if `bias` has been explicitly set.
  var hasBias: Bool {return _storage._bias != nil}
  /// Clears the value of `bias`. Subsequent reads from it will return its default value.
  mutating func clearBias() {_uniqueStorage()._bias = nil}

  ///*
  /// The output shape, which has length 2 ``[H_out, W_out]``.
  /// This is used only for deconvolution (``isDeconvolution == true``).
  /// If not set, the deconvolution output shape is calculated
  /// based on ``ConvolutionPaddingType``.
  var outputShape: [UInt64] {
    get {return _storage._outputShape}
    set {_uniqueStorage()._outputShape = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///*
  /// The type of padding.
  enum OneOf_ConvolutionPaddingType: Equatable {
    case valid(CoreML_Specification_ValidPadding)
    case same(CoreML_Specification_SamePadding)

  #if !swift(>=4.1)
    static func ==(lhs: CoreML_Specification_ConvolutionLayerParams.OneOf_ConvolutionPaddingType, rhs: CoreML_Specification_ConvolutionLayerParams.OneOf_ConvolutionPaddingType) -> Bool {
      switch (lhs, rhs) {
      case (.valid(let l), .valid(let r)): return l == r
      case (.same(let l), .same(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A layer that performs a matrix vector product.
/// This is equivalent to a fully-connected, or dense layer.
///
/// .. code::
///
///      y = InnerProductLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///  A blob with shape ``[C_in]`` or ``[C_in, 1, 1]``, where ``C_in`` is equal to ``inputChannels``.
///
/// Output
///  A blob with shape ``[C_out]``, where ``C_out`` is equal to ``outputChannels``.
struct CoreML_Specification_InnerProductLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Input size: C_in.
  var inputChannels: UInt64 {
    get {return _storage._inputChannels}
    set {_uniqueStorage()._inputChannels = newValue}
  }

  //// Output size: C_out.
  var outputChannels: UInt64 {
    get {return _storage._outputChannels}
    set {_uniqueStorage()._outputChannels = newValue}
  }

  //// Whether a bias is added or not.
  var hasBias_p: Bool {
    get {return _storage._hasBias_p}
    set {_uniqueStorage()._hasBias_p = newValue}
  }

  //// Weight matrix [C_out, C_in].
  var weights: CoreML_Specification_WeightParams {
    get {return _storage._weights ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._weights = newValue}
  }
  /// Returns true if `weights` has been explicitly set.
  var hasWeights: Bool {return _storage._weights != nil}
  /// Clears the value of `weights`. Subsequent reads from it will return its default value.
  mutating func clearWeights() {_uniqueStorage()._weights = nil}

  //// Bias vector [C_out].
  var bias: CoreML_Specification_WeightParams {
    get {return _storage._bias ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._bias = newValue}
  }
  /// Returns true if `bias` has been explicitly set.
  var hasBias: Bool {return _storage._bias != nil}
  /// Clears the value of `bias`. Subsequent reads from it will return its default value.
  mutating func clearBias() {_uniqueStorage()._bias = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A layer that performs a matrix lookup and optionally adds a bias.
///
/// .. code::
///
///      y = EmbeddingLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     A sequence of integers with shape ``[1]`` or ``[1, 1, 1]``, (equivalent to ``[Seq_length, 1, 1, 1]``).
///     Input values must be in the range ``[0, inputDim - 1]``.
///
/// Output
///     A sequence of 1-dimensional features of size ``outputChannels``
///     (equivalent to ``[Seq_length, outputChannels, 1, 1]``).
struct CoreML_Specification_EmbeddingLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Size of the input dictionary.
  var inputDim: UInt64 {
    get {return _storage._inputDim}
    set {_uniqueStorage()._inputDim = newValue}
  }

  //// Size of the output vectors.
  var outputChannels: UInt64 {
    get {return _storage._outputChannels}
    set {_uniqueStorage()._outputChannels = newValue}
  }

  //// Whether a bias is added or not.
  var hasBias_p: Bool {
    get {return _storage._hasBias_p}
    set {_uniqueStorage()._hasBias_p = newValue}
  }

  //// 2-D weights of dimensions [outputChannels, inputDim].
  var weights: CoreML_Specification_WeightParams {
    get {return _storage._weights ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._weights = newValue}
  }
  /// Returns true if `weights` has been explicitly set.
  var hasWeights: Bool {return _storage._weights != nil}
  /// Clears the value of `weights`. Subsequent reads from it will return its default value.
  mutating func clearWeights() {_uniqueStorage()._weights = nil}

  //// Bias of size [outputChannels].
  var bias: CoreML_Specification_WeightParams {
    get {return _storage._bias ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._bias = newValue}
  }
  /// Returns true if `bias` has been explicitly set.
  var hasBias: Bool {return _storage._bias != nil}
  /// Clears the value of `bias`. Subsequent reads from it will return its default value.
  mutating func clearBias() {_uniqueStorage()._bias = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A layer that performs batch normalization,
/// which is performed along the channel axis,
/// and repeated along the other axes, if present.
///
/// .. code::
///
///      y = BatchnormLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// This operation is described by the following formula:
///
/// .. math::
///     y_i = \gamma_i \dfrac{ (x_i - \mu_i)}{\sqrt{\sigma_i^2 + \epsilon}} + \beta_i \;,\;i=1,....,C
///
/// Input
///     A blob with shape ``[C]`` or ``[C, H, W]``.
///
/// Output
///     A blob with the same shape as the input.
struct CoreML_Specification_BatchnormLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Size of the channel dimension in the input.
  var channels: UInt64 {
    get {return _storage._channels}
    set {_uniqueStorage()._channels = newValue}
  }

  ///*
  /// If ``computeMeanVar == true``,
  /// the mean and variance are calculated from either
  /// the single input instance, if ``instanceNormalization == true``,
  /// or the whole batch, if ``instanceNormalization = false``.
  /// and the values provided in parameters "mean" and "variance" are ignored.
  var computeMeanVar: Bool {
    get {return _storage._computeMeanVar}
    set {_uniqueStorage()._computeMeanVar = newValue}
  }

  var instanceNormalization: Bool {
    get {return _storage._instanceNormalization}
    set {_uniqueStorage()._instanceNormalization = newValue}
  }

  ///*
  /// A small constant to avoid division by 0 while normalizing by variance.
  /// Defaults to ``1e-5`` if not set or set to ``0``.
  var epsilon: Float {
    get {return _storage._epsilon}
    set {_uniqueStorage()._epsilon = newValue}
  }

  //// Parameter of length [channels]
  var gamma: CoreML_Specification_WeightParams {
    get {return _storage._gamma ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._gamma = newValue}
  }
  /// Returns true if `gamma` has been explicitly set.
  var hasGamma: Bool {return _storage._gamma != nil}
  /// Clears the value of `gamma`. Subsequent reads from it will return its default value.
  mutating func clearGamma() {_uniqueStorage()._gamma = nil}

  //// Parameter of length [channels]
  var beta: CoreML_Specification_WeightParams {
    get {return _storage._beta ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._beta = newValue}
  }
  /// Returns true if `beta` has been explicitly set.
  var hasBeta: Bool {return _storage._beta != nil}
  /// Clears the value of `beta`. Subsequent reads from it will return its default value.
  mutating func clearBeta() {_uniqueStorage()._beta = nil}

  //// Parameter of length [channels]
  var mean: CoreML_Specification_WeightParams {
    get {return _storage._mean ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._mean = newValue}
  }
  /// Returns true if `mean` has been explicitly set.
  var hasMean: Bool {return _storage._mean != nil}
  /// Clears the value of `mean`. Subsequent reads from it will return its default value.
  mutating func clearMean() {_uniqueStorage()._mean = nil}

  //// Parameter of length [channels]
  var variance: CoreML_Specification_WeightParams {
    get {return _storage._variance ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._variance = newValue}
  }
  /// Returns true if `variance` has been explicitly set.
  var hasVariance: Bool {return _storage._variance != nil}
  /// Clears the value of `variance`. Subsequent reads from it will return its default value.
  mutating func clearVariance() {_uniqueStorage()._variance = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A spatial pooling layer.
///
/// .. code::
///
///      y = PoolingLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with shape ``[C, H_in, W_in]``.
/// Output
///     A blob with shape ``[C, H_out, W_out]``.
///
/// Padding options are similar to ``ConvolutionLayerParams``
/// with the additional option of ``ValidCompletePadding`` (``includeLastPixel``),
/// which ensures that the last application of the kernel
/// always includes the last pixel of the input image, if there is padding.
///
/// .. code::
///
///     H_out = int_division_round_up((H_in + 2 * paddingAmounts[0] - kernelSize[0]),Stride[0]) + 1)
///     if (paddingAmounts[0] > 0 or paddingAmounts[1] > 0)
///          if ((H_out - 1) * Stride >= H_in + paddingAmounts[0]) {
///              H_out = H_out - 1
///          }
///     }
///
/// The equivalent expressions hold true for ``W_out`` as well.
/// Only symmetric padding is supported with this option.
struct CoreML_Specification_PoolingLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Type of pooling operation.
  var type: CoreML_Specification_PoolingLayerParams.PoolingType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  ///*
  /// Must be length 2 in the order ``[H, W]``.
  /// If not set, default value ``[3, 3]`` is used.
  var kernelSize: [UInt64] {
    get {return _storage._kernelSize}
    set {_uniqueStorage()._kernelSize = newValue}
  }

  ///*
  /// Must be length 2 in the order ``[H, W]``.
  /// If not set, default value ``[1, 1]`` is used.
  var stride: [UInt64] {
    get {return _storage._stride}
    set {_uniqueStorage()._stride = newValue}
  }

  var poolingPaddingType: OneOf_PoolingPaddingType? {
    get {return _storage._poolingPaddingType}
    set {_uniqueStorage()._poolingPaddingType = newValue}
  }

  var valid: CoreML_Specification_ValidPadding {
    get {
      if case .valid(let v)? = _storage._poolingPaddingType {return v}
      return CoreML_Specification_ValidPadding()
    }
    set {_uniqueStorage()._poolingPaddingType = .valid(newValue)}
  }

  var same: CoreML_Specification_SamePadding {
    get {
      if case .same(let v)? = _storage._poolingPaddingType {return v}
      return CoreML_Specification_SamePadding()
    }
    set {_uniqueStorage()._poolingPaddingType = .same(newValue)}
  }

  var includeLastPixel: CoreML_Specification_PoolingLayerParams.ValidCompletePadding {
    get {
      if case .includeLastPixel(let v)? = _storage._poolingPaddingType {return v}
      return CoreML_Specification_PoolingLayerParams.ValidCompletePadding()
    }
    set {_uniqueStorage()._poolingPaddingType = .includeLastPixel(newValue)}
  }

  ///*
  /// If true, padded values are excluded from the count (denominator)
  /// when computing average pooling.
  var avgPoolExcludePadding: Bool {
    get {return _storage._avgPoolExcludePadding}
    set {_uniqueStorage()._avgPoolExcludePadding = newValue}
  }

  ///*
  /// If true, global pooling is performed.
  /// Kernel size is inferred from the input data spatial dimensions.
  var globalPooling: Bool {
    get {return _storage._globalPooling}
    set {_uniqueStorage()._globalPooling = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_PoolingPaddingType: Equatable {
    case valid(CoreML_Specification_ValidPadding)
    case same(CoreML_Specification_SamePadding)
    case includeLastPixel(CoreML_Specification_PoolingLayerParams.ValidCompletePadding)

  #if !swift(>=4.1)
    static func ==(lhs: CoreML_Specification_PoolingLayerParams.OneOf_PoolingPaddingType, rhs: CoreML_Specification_PoolingLayerParams.OneOf_PoolingPaddingType) -> Bool {
      switch (lhs, rhs) {
      case (.valid(let l), .valid(let r)): return l == r
      case (.same(let l), .same(let r)): return l == r
      case (.includeLastPixel(let l), .includeLastPixel(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  enum PoolingType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case max // = 0
    case average // = 1
    case l2 // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .max
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .max
      case 1: self = .average
      case 2: self = .l2
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .max: return 0
      case .average: return 1
      case .l2: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  struct ValidCompletePadding {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///*
    /// Must be length 2 in order ``[H, W]``.
    /// If not set, value ``[0, 0]`` is used.
    var paddingAmounts: [UInt64] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension CoreML_Specification_PoolingLayerParams.PoolingType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [CoreML_Specification_PoolingLayerParams.PoolingType] = [
    .max,
    .average,
    .l2,
  ]
}

#endif  // swift(>=4.2)

///*
/// A layer that performs padding along spatial dimensions.
///
/// .. code::
///
///      y = PaddingLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with shape ``[C, H_in, W_in]``.
///
/// Output
///     A blob with shape ``[C, H_out, W_out]``.
///
/// Output dimensions are calculated as follows:
///
/// .. code::
///
///     H_out = H_in + topPaddingAmount + bottomPaddingAmount
///     W_out = W_in + leftPaddingAmount + rightPaddingAmount
///
///     topPaddingAmount == Height startEdgeSize == borderAmounts[0].startEdgeSize
///     bottomPaddingAmount == Height endEdgeSize == borderAmounts[0].endEdgeSize
///     leftPaddingAmount == Width startEdgeSize == borderAmounts[1].startEdgeSize
///     rightPaddingAmount == Width endEdgeSize == borderAmounts[1].endEdgeSize
///
/// There are three types of padding:
///
/// - ``PaddingConstant``, which fills a constant value at the border.
/// - ``PaddingReflection``, which reflects the values at the border.
/// - ``PaddingReplication``, which replicates the values at the border.
///
/// Given the following input:
///
/// .. code::
///
///     [1, 3, 4]  :  1   2   3   4
///                   5   6   7   8
///                   9   10  11  12
///
/// Here is the output of applying the padding
/// ``(top=2, left=2, bottom=0, right=0)``
/// with each of the supported types:
///
/// - ``PaddingConstant`` (``value = 0``):
///   .. code::
///
///       [1, 5, 6]  :  0   0   0  0   0   0
///                     0   0   0  0   0   0
///                     0   0   1  2   3   4
///                     0   0   5  6   7   8
///                     0   0   9  10  11  12
///
/// - ``PaddingReflection``:
///   .. code::
///
///       [1, 5, 6]  :  11  10  9  10  11  12
///                     7   6   5  6   7   8
///                     3   2   1  2   3   4
///                     7   6   5  6   7   8
///                     11  10  9  10  11  12
///
/// - ``PaddingReplication``:
///   .. code::
///
///       [1, 5, 6]  :  1   1   1  2   3   4
///                     1   1   1  2   3   4
///                     1   1   1  2   3   4
///                     5   5   5  6   7   8
///                     9   9   9  10  11  12
struct CoreML_Specification_PaddingLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var paddingType: OneOf_PaddingType? {
    get {return _storage._paddingType}
    set {_uniqueStorage()._paddingType = newValue}
  }

  var constant: CoreML_Specification_PaddingLayerParams.PaddingConstant {
    get {
      if case .constant(let v)? = _storage._paddingType {return v}
      return CoreML_Specification_PaddingLayerParams.PaddingConstant()
    }
    set {_uniqueStorage()._paddingType = .constant(newValue)}
  }

  var reflection: CoreML_Specification_PaddingLayerParams.PaddingReflection {
    get {
      if case .reflection(let v)? = _storage._paddingType {return v}
      return CoreML_Specification_PaddingLayerParams.PaddingReflection()
    }
    set {_uniqueStorage()._paddingType = .reflection(newValue)}
  }

  var replication: CoreML_Specification_PaddingLayerParams.PaddingReplication {
    get {
      if case .replication(let v)? = _storage._paddingType {return v}
      return CoreML_Specification_PaddingLayerParams.PaddingReplication()
    }
    set {_uniqueStorage()._paddingType = .replication(newValue)}
  }

  //// Amounts to be padded to the input.
  var paddingAmounts: CoreML_Specification_BorderAmounts {
    get {return _storage._paddingAmounts ?? CoreML_Specification_BorderAmounts()}
    set {_uniqueStorage()._paddingAmounts = newValue}
  }
  /// Returns true if `paddingAmounts` has been explicitly set.
  var hasPaddingAmounts: Bool {return _storage._paddingAmounts != nil}
  /// Clears the value of `paddingAmounts`. Subsequent reads from it will return its default value.
  mutating func clearPaddingAmounts() {_uniqueStorage()._paddingAmounts = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_PaddingType: Equatable {
    case constant(CoreML_Specification_PaddingLayerParams.PaddingConstant)
    case reflection(CoreML_Specification_PaddingLayerParams.PaddingReflection)
    case replication(CoreML_Specification_PaddingLayerParams.PaddingReplication)

  #if !swift(>=4.1)
    static func ==(lhs: CoreML_Specification_PaddingLayerParams.OneOf_PaddingType, rhs: CoreML_Specification_PaddingLayerParams.OneOf_PaddingType) -> Bool {
      switch (lhs, rhs) {
      case (.constant(let l), .constant(let r)): return l == r
      case (.reflection(let l), .reflection(let r)): return l == r
      case (.replication(let l), .replication(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  ///*
  /// Fill a constant value in the padded region.
  struct PaddingConstant {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: Float = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  ///*
  /// Reflect the values at the border for padding.
  struct PaddingReflection {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  ///*
  /// Replicate the values at the border for padding.
  struct PaddingReplication {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A layer that concatenates along the channel axis (default) or sequence axis.
///
/// .. code::
///
///      y = ConcatLayer(x1,x2,....)
///
/// Requires more than 1 input and produces 1 output.
///
/// The input and output formats are dependent on ``sequenceConcat``.
///
/// If ``sequenceConcat == true``:
///
/// Input
///     Sequences of length ``Seq_i`` of blobs with shape ``[C, H, W]``.
/// Output
///     A Sequence of length ``summation(Seq_i)`` of blobs with shape ``[C, H, W]``.
///
/// If ``sequenceConcat == false``:
///
/// Input
///     A blob with shape ``[C_i, H, W]``, where ``i = 1, 2, ...``.
/// Output
///     A blob with shape ``[summation(C_i), H, W]``.
struct CoreML_Specification_ConcatLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// If true, concatenate along the sequence axis instead of the channel axis.
  var sequenceConcat: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A layer that performs local response normalization (LRN).
///
/// .. code::
///
///      y = LRNLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with shape ``[C, H, W]``
/// Output
///     A blob with the same shape as the input.
///
/// This layer is described by the following formula:
///
/// .. math::
///     x_i \leftarrow  \dfrac{x_i}{\left ( k + \dfrac{\alpha}{C} \sum_j x_j^2 \right )^\beta}
///
/// where the summation is done over a ``(localSize, 1, 1)`` neighborhood ---
/// that is, over a window "across" channels in 1x1 spatial neighborhoods.
struct CoreML_Specification_LRNLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var alpha: Float = 0

  var beta: Float = 0

  //// Number of channels in the normalization window.
  var localSize: UInt64 = 0

  //// Defaults to 1 if not set or 0. Must be strictly positive.
  var k: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// Softmax Normalization Layer
///
/// A layer that performs softmax normalization.
/// Normalization is done along the channel axis.
///
/// .. code::
///
///      y = SoftmaxLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with shape ``[C]`` or ``[C, H, W]``.
/// Output
///     A blob with the same shape as the input.
///
/// This layer is described by the following formula:
///
/// .. math::
///     x_i \leftarrow \dfrac{e^{x_i}}{\sum_i{e^{x_i}}}
struct CoreML_Specification_SoftmaxLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A layer that uniformly splits across the channel dimension
/// to produce a specified number of outputs.
///
/// .. code::
///
///      (y1,y2,...yN) = SplitLayer(x), where N = nOutputs
///
/// Requires 1 input and produces multiple outputs.
///
/// Input
///     A blob with shape ``[C]`` or ``[C, H, W]``
/// Output
///     ``nOutputs`` blobs with shapes
///     ``[C/nOutputs]`` or ``[C/nOutputs, H, W]``
struct CoreML_Specification_SplitLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The number of outputs.
  var nOutputs: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A layer that performs elementwise addition.
///
/// .. code::
///
///      y = AddLayer(x1,x2,...)
///
/// Requires 1 or more than 1 input and produces 1 output.
///
/// Input
///     One or more blobs with broadcastable shapes ``[1]``, ``[C]``, ``[1, H, W]``, or ``[C, H, W]``.
/// Output
///     A blob with shape equal to the input blob.
///
/// If only one input is provided, scalar addition is performed:
///
/// .. math::
///     y = x + \alpha
struct CoreML_Specification_AddLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// Scalar to be added to the input.
  /// Only used if there is a single input.
  var alpha: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A layer that performs elementwise multiplication.
///
/// .. code::
///
///      y = MultiplyLayer(x1,x2,...)
///
/// Requires 1 or more than 1 input and produces 1 output.
///
/// Input
///     One or more blobs with broadcastable shapes ``[1]``, ``[C]``, ``[1, H, W]``, or ``[C, H, W]``.
/// Output
///     A blob with shape equal to the first input blob.
///
/// If only one input is provided, scalar multiplication is performed:
///
/// .. math::
///     y = \alpha x
struct CoreML_Specification_MultiplyLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// Scalar to be multiplied with the input.
  /// Only used if there is a single input.
  var alpha: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A layer that applies a unary function.
///
/// .. code::
///
///      y = UnaryFunctionLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with shape ``[C]`` or ``[C, H, W]``.
/// Output
///     A blob with the same shape as the input.
///
/// The input is first modified by shifting and scaling:
///
/// .. math::
///     x \leftarrow \text{scale} \cdot x + \text{shift}
struct CoreML_Specification_UnaryFunctionLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The type of unary function.
  var type: CoreML_Specification_UnaryFunctionLayerParams.Operation = .sqrt

  ///*
  /// A constant used in ``POWER`` and ``THRESHOLD`` functions.
  var alpha: Float = 0

  ///*
  /// A small constant to avoid division by 0 while normalizing variance.
  /// Defaults to ``1e-6`` if not set or set to ``0``.
  var epsilon: Float = 0

  ///*
  /// Input is shifted by this amount
  /// before the unary function is applied.
  /// Defaults to ``0.0`` if not set.
  var shift: Float = 0

  ///*
  /// Input is scaled by this amount
  /// before the unary function is applied.
  /// Defaults to ``1.0`` if not set or set to ``0``.
  var scale: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///*
  /// A unary operator.
  ///
  /// The following functions are supported:
  ///
  /// ``SQRT``
  ///     .. math:: f(x) = \sqrt{x}
  ///
  /// ``RSQRT``
  ///     .. math:: f(x) = \dfrac{1}{\sqrt{x + \epsilon}}
  ///
  /// ``INVERSE``
  ///     .. math:: f(x) = \dfrac{1}{x + \epsilon}
  ///
  /// ``POWER``
  ///     .. math:: f(x) = x^\alpha
  ///
  /// ``EXP``
  ///     .. math:: f(x) = e^x
  ///
  /// ``LOG``
  ///     .. math:: f(x) = \log x
  ///
  /// ``ABS``
  ///     .. math:: f(x) = |x|
  ///
  /// ``THRESHOLD``
  ///     .. math:: f(x) = \text{max}(\alpha, x)
  enum Operation: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case sqrt // = 0
    case rsqrt // = 1
    case inverse // = 2
    case power // = 3
    case exp // = 4
    case log // = 5
    case abs // = 6
    case threshold // = 7
    case UNRECOGNIZED(Int)

    init() {
      self = .sqrt
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .sqrt
      case 1: self = .rsqrt
      case 2: self = .inverse
      case 3: self = .power
      case 4: self = .exp
      case 5: self = .log
      case 6: self = .abs
      case 7: self = .threshold
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .sqrt: return 0
      case .rsqrt: return 1
      case .inverse: return 2
      case .power: return 3
      case .exp: return 4
      case .log: return 5
      case .abs: return 6
      case .threshold: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension CoreML_Specification_UnaryFunctionLayerParams.Operation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [CoreML_Specification_UnaryFunctionLayerParams.Operation] = [
    .sqrt,
    .rsqrt,
    .inverse,
    .power,
    .exp,
    .log,
    .abs,
    .threshold,
  ]
}

#endif  // swift(>=4.2)

///*
/// A layer that scales up spatial dimensions.
/// It supports two modes: nearest neighbour (default) and bilinear.
///
/// .. code::
///
///      y = UpsampleLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with shape ``[C, H, W]``.
/// Output
///     A blob with shape ``[C, scalingFactor[0] * H, scalingFactor[1] * W]``
struct CoreML_Specification_UpsampleLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// Scaling Factor.
  /// Must be length 2 in order ``[H, W]``.
  /// If not set, default value ``[1, 1]`` is used.
  var scalingFactor: [UInt64] = []

  var mode: CoreML_Specification_UpsampleLayerParams.InterpolationMode = .nn

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum InterpolationMode: SwiftProtobuf.Enum {
    typealias RawValue = Int

    //// Nearest Neighbour
    case nn // = 0

    //// Bilinear
    case bilinear // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .nn
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .nn
      case 1: self = .bilinear
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .nn: return 0
      case .bilinear: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension CoreML_Specification_UpsampleLayerParams.InterpolationMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [CoreML_Specification_UpsampleLayerParams.InterpolationMode] = [
    .nn,
    .bilinear,
  ]
}

#endif  // swift(>=4.2)

///*
/// A layer that resizes the input to a pre-specified spatial size using bilinear interpolation. 
///
/// .. code::
///
///      y = ResizeBilinearLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with shape ``[C, H_in, W_in]``. 
///
/// Output
///     A blob with shape ``[C, H_out, W_out]``.
struct CoreML_Specification_ResizeBilinearLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// Target Spatial Size.
  /// Must be length 2 in order ``[Height, Width]``, i.e. ``[H_out, W_out]``.
  /// If not set, default value ``[1, 1]`` is used.
  var targetSize: [UInt64] {
    get {return _storage._targetSize}
    set {_uniqueStorage()._targetSize = newValue}
  }

  ///*
  /// Mode used to compute the grid on which the spatial output values are evaluated.
  /// Same mode is applied to both the height and width axes. 
  var mode: CoreML_Specification_SamplingMode {
    get {return _storage._mode ?? CoreML_Specification_SamplingMode()}
    set {_uniqueStorage()._mode = newValue}
  }
  /// Returns true if `mode` has been explicitly set.
  var hasMode: Bool {return _storage._mode != nil}
  /// Clears the value of `mode`. Subsequent reads from it will return its default value.
  mutating func clearMode() {_uniqueStorage()._mode = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A layer that extracts cropped spatial patches or RoIs (regions of interest) from the input and resizes them to a pre-specified size using
/// bilinear interpolation. 
/// Note that RoI Align layer can be implemented with this layer followed by a pooling layer.
///
/// .. code::
///
///      y = CropResizeLayer(x)
///
/// Requires 2 inputs and produces 1 output.
///
/// Input
///     A blob with shape ``[C, H_in, W_in]``. 
///			This represents an image feature map. 
///			Note that the full batched input shape is ``[Seq = 1, Batch = Batch, C, H_in, W_in]``
///     A second input with shape ``[N, 4, 1, 1]`` or ``[N, 5, 1, 1]``. 
///			This represents the bounding box coordinates for N patches/RoIs. 
///			Note that the full batched shape is ``[Seq = N, Batch = 1, C = 4 or 5, 1, 1]``
///			That is, sequence dimension = N, channel dimension = 4 or 5.
///
///     N: number of patches/RoIs to be extracted
///     If RoI shape = ``[N, 4, 1, 1]``
///                    The channel axis corresponds to the four coordinates specifying the bounding box.
///                    All the N RoIs are extracted from all the batches of the input. 
///     If RoI shape = ``[N, 5, 1, 1]``
///                     The first element of the channel axis specifies the input batch id from which to extract the RoI and 
///					  must be in the interval ``[0, Batch - 1]``. That is, n-th RoI is extracted from the RoI[n,0,0,0]-th input batch id. 
///                     The last four elements of the channel axis specify the bounding box coordinates. 
///
/// Output
///     A blob with shape ``[N, C, H_out, W_out]``. 
///			This represents the output image feature map for each input RoI. 
///	  		Note that the full batched output shape is:
///			- ``[Seq = N, Batch = Batch, C, H_out, W_out]`` if input RoI shape is ``[N, 4, 1, 1]``
///			- ``[Seq = N, Batch = 1, C, H_out, W_out]`` if input RoI shape is ``[N, 5, 1, 1]``
struct CoreML_Specification_CropResizeLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// Target Spatial Size.
  /// Must be length 2 in order ``[Height, Width]``, i.e. ``[H_out, W_out]``.
  /// If not set, default value ``[1, 1]`` is used.
  var targetSize: [UInt64] {
    get {return _storage._targetSize}
    set {_uniqueStorage()._targetSize = newValue}
  }

  ///*
  /// If true the bounding box coordinates must be in the interval [0, 1].
  /// They are scaled by (H_in - 1), (W_in - 1), i.e. based on the input spatial dimensions.  
  /// If false the bounding box coordinates must be in the interval
  /// [0, H_in -1] and [0, W_in - 1], respectively for height and width dimensions.
  var normalizedCoordinates: Bool {
    get {return _storage._normalizedCoordinates}
    set {_uniqueStorage()._normalizedCoordinates = newValue}
  }

  ///*
  /// Mode used to compute the grid on which the spatial output values are evaluated.
  /// Same mode is applied to both the height and width axes. 
  var mode: CoreML_Specification_SamplingMode {
    get {return _storage._mode ?? CoreML_Specification_SamplingMode()}
    set {_uniqueStorage()._mode = newValue}
  }
  /// Returns true if `mode` has been explicitly set.
  var hasMode: Bool {return _storage._mode != nil}
  /// Clears the value of `mode`. Subsequent reads from it will return its default value.
  mutating func clearMode() {_uniqueStorage()._mode = nil}

  ///*
  /// Representation used to express the bounding box coordinates. 
  /// It determines how the values of the second input are interpreted. 
  var boxIndicesMode: CoreML_Specification_BoxCoordinatesMode {
    get {return _storage._boxIndicesMode ?? CoreML_Specification_BoxCoordinatesMode()}
    set {_uniqueStorage()._boxIndicesMode = newValue}
  }
  /// Returns true if `boxIndicesMode` has been explicitly set.
  var hasBoxIndicesMode: Bool {return _storage._boxIndicesMode != nil}
  /// Clears the value of `boxIndicesMode`. Subsequent reads from it will return its default value.
  mutating func clearBoxIndicesMode() {_uniqueStorage()._boxIndicesMode = nil}

  ///*
  /// Additional spatial scale that multiplies the bounding box coordinates. 
  /// Generally used while implementing the RoI Align layer, 
  /// which uses unnormalized RoI coordinates along with a spatial scale less than or equal to 1. 
  var spatialScale: Float {
    get {return _storage._spatialScale}
    set {_uniqueStorage()._spatialScale = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A layer that performs elementwise addition of a bias,
/// which is broadcasted to match the input shape.
///
/// .. code::
///
///      y = BiasLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with shape ``[C, H, W]``.
/// Output
///     A blob with the same shape as the input.
struct CoreML_Specification_BiasLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The shape of the bias.
  /// Must be one of the following:
  /// ``[1]``, ``[C]``, ``[1, H, W]`` or ``[C, H, W]``.
  var shape: [UInt64] {
    get {return _storage._shape}
    set {_uniqueStorage()._shape = newValue}
  }

  ///*
  /// The bias values.
  /// The size must be equal to the product of the ``shape`` dimensions.
  var bias: CoreML_Specification_WeightParams {
    get {return _storage._bias ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._bias = newValue}
  }
  /// Returns true if `bias` has been explicitly set.
  var hasBias: Bool {return _storage._bias != nil}
  /// Clears the value of `bias`. Subsequent reads from it will return its default value.
  mutating func clearBias() {_uniqueStorage()._bias = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A layer that performs elmentwise multiplication by a scale factor
/// and optionally adds a bias;
/// both the scale and bias are broadcasted to match the input shape.
///
/// .. code::
///
///      y = ScaleLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with shape ``[C, H, W]``.
/// Output
///     A blob with the same shape as the input.
struct CoreML_Specification_ScaleLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The shape of the scale.
  /// Must be one of the following:
  /// ``[1]``, ``[C]``, ``[1, H, W]`` or ``[C, H, W]``.
  var shapeScale: [UInt64] {
    get {return _storage._shapeScale}
    set {_uniqueStorage()._shapeScale = newValue}
  }

  ///*
  /// The scale values.
  /// The size must be equal to the product of the ``shape`` dimensions.
  var scale: CoreML_Specification_WeightParams {
    get {return _storage._scale ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._scale = newValue}
  }
  /// Returns true if `scale` has been explicitly set.
  var hasScale: Bool {return _storage._scale != nil}
  /// Clears the value of `scale`. Subsequent reads from it will return its default value.
  mutating func clearScale() {_uniqueStorage()._scale = nil}

  //// If true, a bias is added after scaling.
  var hasBias_p: Bool {
    get {return _storage._hasBias_p}
    set {_uniqueStorage()._hasBias_p = newValue}
  }

  ///*
  /// The shape of the bias.
  /// Must be one of the following:
  /// ``[1]``, ``[C]``, ``[1, H, W]`` or ``[C, H, W]``.
  var shapeBias: [UInt64] {
    get {return _storage._shapeBias}
    set {_uniqueStorage()._shapeBias = newValue}
  }

  ///*
  /// The bias values.
  /// The size must be equal to the product of the ``shape`` dimensions.
  var bias: CoreML_Specification_WeightParams {
    get {return _storage._bias ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._bias = newValue}
  }
  /// Returns true if `bias` has been explicitly set.
  var hasBias: Bool {return _storage._bias != nil}
  /// Clears the value of `bias`. Subsequent reads from it will return its default value.
  mutating func clearBias() {_uniqueStorage()._bias = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A layer that loads data as a parameter and provides it as an output.
///
/// .. code::
///
///      y = LoadConstantLayer()
///
/// Takes no input. Produces 1 output.
///
/// Input
///     None
/// Output:
///     A blob with shape ``[C, H, W]``
struct CoreML_Specification_LoadConstantLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The shape of the constant to be loaded,
  /// which must be``[C, H, W]``.
  var shape: [UInt64] {
    get {return _storage._shape}
    set {_uniqueStorage()._shape = newValue}
  }

  ///*
  /// The data values,
  /// of size ``C * H * W``.
  var data: CoreML_Specification_WeightParams {
    get {return _storage._data ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {_uniqueStorage()._data = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A layer that performs L2 normalization, i.e. divides by the
/// the square root of the sum of squares of all elements of input.
///
/// .. code::
///
///      y = L2NormalizeLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with shape ``[C]`` or ``[C, H, W]``.
/// Output
///     A blob with the same shape as the input.
///
/// This layer is described by the following formula:
///
/// .. math::
///     x_i \leftarrow \dfrac{x_i}{\sqrt{\sum{x_i^2} + \epsilon}}
struct CoreML_Specification_L2NormalizeLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A small constant to avoid division by 0 while normalizing variance.
  /// Defaults to ``1e-6`` if not set or set to ``0``.
  var epsilon: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A layer that flattens the input.
///
/// .. code::
///
///      y = FlattenLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with shape ``[C, H, W]``.
/// Output
///     A blob with shape ``[C * H * W, 1, 1]``
///
/// There are two flatten orders: ``CHANNEL_FIRST`` and ``CHANNEL_LAST``.
/// ``CHANNEL_FIRST`` does not require data to be rearranged,
/// because row major ordering is used by internal storage.
/// ``CHANNEL_LAST`` requires data to be rearranged.
struct CoreML_Specification_FlattenLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mode: CoreML_Specification_FlattenLayerParams.FlattenOrder = .channelFirst

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum FlattenOrder: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case channelFirst // = 0
    case channelLast // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .channelFirst
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .channelFirst
      case 1: self = .channelLast
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .channelFirst: return 0
      case .channelLast: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension CoreML_Specification_FlattenLayerParams.FlattenOrder: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [CoreML_Specification_FlattenLayerParams.FlattenOrder] = [
    .channelFirst,
    .channelLast,
  ]
}

#endif  // swift(>=4.2)

///*
/// A layer that recasts the input into a new shape.
///
/// .. code::
///
///      y = ReshapeLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with shape ``[C, H, W]`` or ``[Seq, C, H, W]``.
/// Output
///     A blob with shape ``[C_out, H_out, W_out]``
///     or ``[Seq_out, C_out, H_out, W_out]``.
///
/// There are two reshape orders: ``CHANNEL_FIRST`` and ``CHANNEL_LAST``.
/// ``CHANNEL_FIRST`` is equivalent to
/// flattening the input to ``[C * H * W, 1, 1]`` in channel first order
/// and then reshaping it to the target shape;
/// no data rearrangement is required.
/// ``CHANNEL_LAST`` is equivalent to
/// flattening the input to ``[H * W * C, 1, 1]`` in channel last order,
/// reshaping it to ``[H_out, W_out, C_out]`` (it is now in "H_out-major"" order),
/// and then permuting it to ``[C_out, H_out, W_out]``;
/// both the flattening and permuting requires the data to be rearranged.
struct CoreML_Specification_ReshapeLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The shape of the output.
  /// Must be of length 3 or 4.
  /// If set to 3, ``targetShape`` is interpreted as
  /// ``[C_out, H_out, W_out]``, and sequence length of the input is preserved.
  /// If set to 4, ``targetShape`` is interpreted as
  /// ``[Seq_out, C_out, H_out, W_out]``,
  /// where ``Seq_out`` is the new sequence length.
  var targetShape: [Int64] = []

  var mode: CoreML_Specification_ReshapeLayerParams.ReshapeOrder = .channelFirst

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ReshapeOrder: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case channelFirst // = 0
    case channelLast // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .channelFirst
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .channelFirst
      case 1: self = .channelLast
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .channelFirst: return 0
      case .channelLast: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension CoreML_Specification_ReshapeLayerParams.ReshapeOrder: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [CoreML_Specification_ReshapeLayerParams.ReshapeOrder] = [
    .channelFirst,
    .channelLast,
  ]
}

#endif  // swift(>=4.2)

///*
/// A layer that rearranges the dimensions and data of an input.
///
/// .. code::
///
///      y = PermuteLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     A sequence of 3-dimensional blobs. ``InputShape = [Seq, C, H, W]``.
/// Output
///     A sequence of a different length of 3-dimensional blobs.
///     Shape: ``[InputShape[axis[0]], InputShape[axis[1]],
///     InputShape[axis[2]], InputShape[axis[3]]]``. Hence output is a sequence of length ``InputShape[axis[0]]``.
///
/// Examples:
///
/// - If ``axis`` is set to ``[0, 3, 1, 2]``,
///   then the output has shape ``[W,C,H]``
///   and has the same sequence length that of the input.
///
/// - If ``axis`` is set to ``[3, 1, 2, 0]``,
///   and the input is a sequence of data
///   with length ``Seq`` and shape ``[C, 1, 1]``,
///   then the output is a unit sequence of data with shape ``[C, 1, Seq]``.
///
/// - If ``axis`` is set to ``[0, 3, 2, 1]``,
///   the output is a reverse of the input: ``[C, H, W] -> [W, H, C]``.
///
/// - If ``axis`` is not set, or is set to ``[0, 1, 2, 3]``,
///   the output is the same as the input.
struct CoreML_Specification_PermuteLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The order in which to permute the dimensions.
  /// Must have length 4 and a permutation of ``[0, 1, 2, 3]``.
  var axis: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A layer that reorganizes data in the input in specific ways.
///
/// .. code::
///
///      y = ReorganizeDataLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with shape ``[C, H, W]``.
/// Output
///     A blob with shape ``[C_out, H_out, W_out]``.
///
/// mode == SPACE_TO_DEPTH
///  ``[C_out, H_out, W_out]`` : ``[C * blockSize * blockSize, H/blockSize, W/blockSize]``.
///  blockSize must divide H and W.
///  Data is moved from the spatial dimensions to the channel dimension. Input is spatially divided into
///  non-overlapping blocks of size blockSize X blockSize and data from each block is moved into the
///  channel dimension.
///
/// mode == DEPTH_TO_SPACE
///  ``[C_out, H_out, W_out]`` : ``[C/(blockSize * blockSize), H * blockSize, W * blockSize]``.
///  Square of blockSize must divide C.
///  Reverse of SPACE_TO_DEPTH. Data is moved from the channel dimension to the spatial dimensions.
struct CoreML_Specification_ReorganizeDataLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mode: CoreML_Specification_ReorganizeDataLayerParams.ReorganizationType = .spaceToDepth

  //// must be greater than 1
  var blockSize: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ReorganizationType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case spaceToDepth // = 0
    case depthToSpace // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .spaceToDepth
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .spaceToDepth
      case 1: self = .depthToSpace
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .spaceToDepth: return 0
      case .depthToSpace: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension CoreML_Specification_ReorganizeDataLayerParams.ReorganizationType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [CoreML_Specification_ReorganizeDataLayerParams.ReorganizationType] = [
    .spaceToDepth,
    .depthToSpace,
  ]
}

#endif  // swift(>=4.2)

///*
/// A layer that slices the input data along a given axis.
///
/// .. code::
///
///      y = SliceLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with shape ``[Seq, C, H, W]``.
/// Output
///     A blob with shape ``[Seq_out, C_out, H_out, W_out]``.
///
/// Sliced section is taken from the interval ``[startIndex, endIndex)``, i.e.
/// startIndex is inclusive while endIndex is exclusive.
/// stride must be positive and represents the step size for slicing.
/// Negative indexing is supported for startIndex and endIndex.
/// -1 denotes N-1, -2 denotes N-2 and so on, where N is the length of the dimension to be sliced.
struct CoreML_Specification_SliceLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// start of the sliced section. Inclusive.
  var startIndex: Int64 = 0

  //// end of sliced section. Exclusive.
  var endIndex: Int64 = 0

  //// The step size. Must be positive.
  var stride: UInt64 = 0

  var axis: CoreML_Specification_SliceLayerParams.SliceAxis = .channelAxis

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum SliceAxis: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case channelAxis // = 0
    case heightAxis // = 1
    case widthAxis // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .channelAxis
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .channelAxis
      case 1: self = .heightAxis
      case 2: self = .widthAxis
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .channelAxis: return 0
      case .heightAxis: return 1
      case .widthAxis: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension CoreML_Specification_SliceLayerParams.SliceAxis: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [CoreML_Specification_SliceLayerParams.SliceAxis] = [
    .channelAxis,
    .heightAxis,
    .widthAxis,
  ]
}

#endif  // swift(>=4.2)

///*
/// A layer that reduces the input using a specified operation.
///
/// .. code::
///
///      y = ReduceLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with shape ``[C, H, W]``.
/// Output
///     A blob whose shape depends on the value of axis, the dimension(s) along which reduction is performed.
///     if axis == C   : ``[1, H, W]``
///     if axis == H   : ``[C, 1, W]``
///     if axis == W   : ``[C, H, 1]``
///     if axis == HW  : ``[C, 1, 1]``
///     if axis == CHW : ``[1, 1, 1]`` [Default]
struct CoreML_Specification_ReduceLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Specifies function used to reduce.
  var mode: CoreML_Specification_ReduceLayerParams.ReduceOperation = .sum

  ///*
  /// Used if mode is ``LOGSUM``.
  /// Defaults to ``1e-6`` if not set or is set to ``0``.
  var epsilon: Float = 0

  var axis: CoreML_Specification_ReduceLayerParams.ReduceAxis = .chw

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// The following reduction operations are supported
  /// and are applied on the specified axis of the input array:
  ///
  /// ``SUM``
  ///     Sum of all elements
  ///
  ///     .. math:: \sum{x_i}
  ///
  /// ``AVG``
  ///     Sum of all elements divided by the number of elements
  ///
  ///     .. math:: \dfrac{\sum^n{x_i}}{n}
  ///
  /// ``PROD``
  ///     Product of all elements
  ///
  ///     .. math:: \prod{x_i}
  ///
  /// ``LOGSUM``
  ///     Sum of the natural logarithm of all elements
  ///
  ///     .. math:: \sum{\ln{(x_i + \epsilon)}}
  ///
  /// ``SUMSQUARE``
  ///     Sum of squares of all elements
  ///
  ///     .. math:: \sum{x^2}
  ///
  /// ``L1``
  ///     L1 normalization of all elements
  ///
  ///     .. math:: ||x||_1 = \sum{|x_i|}
  ///
  /// ``L2``
  ///     L2 normalization of all elements
  ///
  ///     .. math:: ||x||_2 = \sqrt{\sum{x_i^2}}
  ///
  /// ``MAX``
  ///     Maximum of all elements
  ///
  ///     .. math:: \text{max}(x_i)
  ///
  /// ``MIN``
  ///     Minumum of all elements
  ///
  ///     .. math:: \text{min}(x_i)
  ///
  /// ``ARGMAX``
  ///     Argument of the maximum of all elements
  ///
  ///     .. math:: \text{argmax}(x_i)
  enum ReduceOperation: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case sum // = 0
    case avg // = 1
    case prod // = 2
    case logsum // = 3
    case sumsquare // = 4
    case l1 // = 5
    case l2 // = 6
    case max // = 7
    case min // = 8

    //// only supported with axis = C, H or W.
    case argmax // = 9
    case UNRECOGNIZED(Int)

    init() {
      self = .sum
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .sum
      case 1: self = .avg
      case 2: self = .prod
      case 3: self = .logsum
      case 4: self = .sumsquare
      case 5: self = .l1
      case 6: self = .l2
      case 7: self = .max
      case 8: self = .min
      case 9: self = .argmax
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .sum: return 0
      case .avg: return 1
      case .prod: return 2
      case .logsum: return 3
      case .sumsquare: return 4
      case .l1: return 5
      case .l2: return 6
      case .max: return 7
      case .min: return 8
      case .argmax: return 9
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  enum ReduceAxis: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case chw // = 0
    case hw // = 1
    case c // = 2
    case h // = 3
    case w // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .chw
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .chw
      case 1: self = .hw
      case 2: self = .c
      case 3: self = .h
      case 4: self = .w
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .chw: return 0
      case .hw: return 1
      case .c: return 2
      case .h: return 3
      case .w: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension CoreML_Specification_ReduceLayerParams.ReduceOperation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [CoreML_Specification_ReduceLayerParams.ReduceOperation] = [
    .sum,
    .avg,
    .prod,
    .logsum,
    .sumsquare,
    .l1,
    .l2,
    .max,
    .min,
    .argmax,
  ]
}

extension CoreML_Specification_ReduceLayerParams.ReduceAxis: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [CoreML_Specification_ReduceLayerParams.ReduceAxis] = [
    .chw,
    .hw,
    .c,
    .h,
    .w,
  ]
}

#endif  // swift(>=4.2)

///*
/// A layer that crops the spatial dimensions of an input.
/// If two inputs are provided, the shape of the second input is used as the reference shape.
///
/// .. code::
///
///      y = CropLayer(x1) or y = CropLayer(x1,x2)
///
/// Requires 1 or 2 inputs and produces 1 output.
///
/// Input
///     - 1 input case: A blob with shape ``[C, H_in, W_in]``.
///     - 2 input case: 1st blob with shape ``[C, H_in, W_in]``, 2nd blob with shape ``[C, H_out, W_out]``.
///
/// Output
///     A blob with shape ``[C, H_out, W_out]``.
///
/// If one input is used, output is computed as follows:
///
/// .. code::
///
///      y = x1[:, topCropAmount:H_in - bottomCropAmount, leftCropAmount:W_in - rightCropAmount]
///
///      topCropAmount == Height startEdgeSize == borderAmounts[0].startEdgeSize
///      bottomCropAmount == Height endEdgeSize == borderAmounts[0].endEdgeSize
///      leftCropAmount == Width startEdgeSize == borderAmounts[1].startEdgeSize
///      rightCropAmount == Width endEdgeSize == borderAmounts[1].endEdgeSize
///
///      H_out = H_in - topCropAmount - bottomCropAmount
///      W_out = W_in - leftCropAmount - rightCropAmount
///
/// If two inputs are used, output is computed as follows:
///
/// .. code::
///
///      y = x1[:, offset[0]:offset[0] + H_out, offset[1]:offset[1] + W_out]
struct CoreML_Specification_CropLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The amounts to be cropped from the input.
  /// Used only if a single input is provided.
  var cropAmounts: CoreML_Specification_BorderAmounts {
    get {return _storage._cropAmounts ?? CoreML_Specification_BorderAmounts()}
    set {_uniqueStorage()._cropAmounts = newValue}
  }
  /// Returns true if `cropAmounts` has been explicitly set.
  var hasCropAmounts: Bool {return _storage._cropAmounts != nil}
  /// Clears the value of `cropAmounts`. Subsequent reads from it will return its default value.
  mutating func clearCropAmounts() {_uniqueStorage()._cropAmounts = nil}

  ///*
  /// The offset amounts.
  /// Used only if two inputs are provided.
  /// Must be of length 2, in order ``[H, W]``.
  var offset: [UInt64] {
    get {return _storage._offset}
    set {_uniqueStorage()._offset = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A layer that computes the elementwise average of the inputs.
///
/// .. code::
///
///      y = AverageLayer(x1,x2,...)
///
/// Requires multiple inputs and produces 1 output.
///
/// Input
///     Multiple blobs with broadcastable shapes ``[1]``, ``[C]``, ``[1, H, W]``, or ``[C, H, W]``.
/// Output
///     A blob with the same shape as each input.
struct CoreML_Specification_AverageLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A layer that computes the elementwise maximum over the inputs.
///
/// .. code::
///
///      y = MaxLayer(x1,x2,...)
///
/// Requires multiple inputs and produces 1 output.
///
/// Input
///     Multiple blobs, each with shape ``[C]`` or ``[C, H, W]``.
/// Output
///     A blob with the same shape as each input.
struct CoreML_Specification_MaxLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A layer that computes the elementwise minimum over the inputs.
///
/// .. code::
///
///      y = MinLayer(x1,x2,...)
///
/// Requires multiple inputs and produces 1 output.
///
/// Input
///     Multiple blobs, each with shape ``[C]`` or ``[C, H, W]``.
/// Output
///     A blob with the same shape as each input.
struct CoreML_Specification_MinLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A layer that computes the dot product of two vectors.
///
/// .. code::
///
///      y = DotProductLayer(x1,x2)
///
/// Requires 2 inputs and produces 1 output.
///
/// Input
///     Two blobs with shape ``[C]``.
/// Output
///     A scalar.
struct CoreML_Specification_DotProductLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// If true, inputs are normalized first,
  /// thereby computing the cosine similarity.
  var cosineSimilarity: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A layer that performs mean variance normalization.
///
/// .. code::
///
///      y = MeanVarianceNormalizeLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with shape ``[C]`` or ``[C, H, W]``.
/// Output
///     A blob with the same shape as the input.
///
/// If ``acrossChannels == true``
/// normalization is performed on flattened input.
///
/// If ``acrossChannels == false``
/// normalization is performed within a channel,
/// across spatial dimensions.
struct CoreML_Specification_MeanVarianceNormalizeLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// If true, mean and variance are computed across channels.
  var acrossChannels: Bool = false

  ///*
  /// If false, only mean is subtracted.
  var normalizeVariance: Bool = false

  ///*
  /// A small constant to avoid division by 0 while normalizing variance.
  /// Defaults to ``1e-6`` if not set or set to ``0``.
  var epsilon: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A layer that repeats a sequence.
///
/// .. code::
///
///      y = SequenceRepeatLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     A sequence of blobs, i.e. shape is either ``[Seq, C]`` or ``[Seq, C, H, W]``.
/// Output
///     A sequence of length ``nRepetitions * Seq``
///     with shape corresponding to the input,
///     i.e. shape is either ``[nRepetitions * Seq, C]`` or ``[nRepetitions * Seq, C, H, W]``.
struct CoreML_Specification_SequenceRepeatLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// Number of repetitions.
  /// Defaults to ``1`` if not set or set to ``0``.
  var nRepetitions: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A simple recurrent layer.
///
/// .. code::
///
///      y_t = SimpleRecurrentLayer(x_t, y_{t-1})
///
/// Input
///    A sequence of vectors of size ``inputVectorSize``
///    with shape ``[Seq, inputVectorSize]``.
/// Output
///    A vector of size ``outputVectorSize``. It is either the final output or a sequence of outputs at all time steps.
///
/// - Output Shape: ``[1,outputVectorSize]`` , if ``sequenceOutput == false``
/// - Output Shape: ``[Seq,outputVectorSize]`` , if ``sequenceOutput == true``
///
/// This layer is described by the following equation:
///
/// .. math::
///     \boldsymbol{y_t} = f(\mathrm{clip}(W \boldsymbol{x_t} + \
///                                        R \boldsymbol{y_{t-1}} + b))
///
/// - ``W`` is a 2-dimensional weight matrix
///   (``[outputVectorSize, inputVectorSize]``, row-major)
/// - ``R`` is a 2-dimensional recursion matrix
///   (``[outputVectorSize, outputVectorSize]``, row-major)
/// - ``b`` is a 1-dimensional bias vector (``[outputVectorSize]``)
/// - ``f()`` is an activation
/// - ``clip()`` is a function that constrains values between ``[-50.0, 50.0]``
struct CoreML_Specification_SimpleRecurrentLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The size of the input vectors.
  var inputVectorSize: UInt64 {
    get {return _storage._inputVectorSize}
    set {_uniqueStorage()._inputVectorSize = newValue}
  }

  //// The size of the output vectors.
  var outputVectorSize: UInt64 {
    get {return _storage._outputVectorSize}
    set {_uniqueStorage()._outputVectorSize = newValue}
  }

  ///*
  /// Activations supported are Linear, Sigmoid, Tanh, ReLU, Scaled Tanh (alpha = 1.71, beta = 2/3), Hard sigmoid (alpha = 0.2, beta = 0.5)
  var activation: CoreML_Specification_ActivationParams {
    get {return _storage._activation ?? CoreML_Specification_ActivationParams()}
    set {_uniqueStorage()._activation = newValue}
  }
  /// Returns true if `activation` has been explicitly set.
  var hasActivation: Bool {return _storage._activation != nil}
  /// Clears the value of `activation`. Subsequent reads from it will return its default value.
  mutating func clearActivation() {_uniqueStorage()._activation = nil}

  ///*
  ///If false output is just the result after final state update.
  ///If true, output is a sequence, containing outputs at all time steps.
  var sequenceOutput: Bool {
    get {return _storage._sequenceOutput}
    set {_uniqueStorage()._sequenceOutput = newValue}
  }

  //// If false, no bias is added.
  var hasBiasVector_p: Bool {
    get {return _storage._hasBiasVector_p}
    set {_uniqueStorage()._hasBiasVector_p = newValue}
  }

  //// Weight matrix W.
  var weightMatrix: CoreML_Specification_WeightParams {
    get {return _storage._weightMatrix ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._weightMatrix = newValue}
  }
  /// Returns true if `weightMatrix` has been explicitly set.
  var hasWeightMatrix: Bool {return _storage._weightMatrix != nil}
  /// Clears the value of `weightMatrix`. Subsequent reads from it will return its default value.
  mutating func clearWeightMatrix() {_uniqueStorage()._weightMatrix = nil}

  //// Recursion Weight matrix R.
  var recursionMatrix: CoreML_Specification_WeightParams {
    get {return _storage._recursionMatrix ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._recursionMatrix = newValue}
  }
  /// Returns true if `recursionMatrix` has been explicitly set.
  var hasRecursionMatrix: Bool {return _storage._recursionMatrix != nil}
  /// Clears the value of `recursionMatrix`. Subsequent reads from it will return its default value.
  mutating func clearRecursionMatrix() {_uniqueStorage()._recursionMatrix = nil}

  //// Bias vector b.
  var biasVector: CoreML_Specification_WeightParams {
    get {return _storage._biasVector ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._biasVector = newValue}
  }
  /// Returns true if `biasVector` has been explicitly set.
  var hasBiasVector: Bool {return _storage._biasVector != nil}
  /// Clears the value of `biasVector`. Subsequent reads from it will return its default value.
  mutating func clearBiasVector() {_uniqueStorage()._biasVector = nil}

  /// If true, then the node processes the input sequence from right to left
  var reverseInput: Bool {
    get {return _storage._reverseInput}
    set {_uniqueStorage()._reverseInput = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// Gated-Recurrent Unit (GRU) Layer
///
/// .. code::
///
///      y_t = GRULayer(x_t, y_{t-1})
///
/// Input
///    A sequence of vectors of size ``inputVectorSize``
///    with shape ``[Seq, inputVectorSize]``.
/// Output
///    A vector of size ``outputVectorSize``. It is either the final output or a sequence of outputs at all time steps.
///
/// - Output Shape: ``[1,outputVectorSize]`` , if ``sequenceOutput == false``
/// - Output Shape: ``[Seq,outputVectorSize]`` , if ``sequenceOutput == true``
///
/// This layer is described by the following equations:
///
/// Update Gate
///     .. math::
///         \boldsymbol{z_t} = \
///             f(\mathrm{clip}(W_z \boldsymbol{x_t} + \
///                             R_z \boldsymbol{y_{t-1}} + b_z)
///
/// Reset Gate
///     .. math::
///         \boldsymbol{r_t} = \
///             f(\mathrm{clip}(W_r \boldsymbol{x_t} + \
///                             R_r \boldsymbol{y_{t-1}} + b_r))
///
/// Cell Memory State
///     .. math::
///         \boldsymbol{c_t} = \
///             \boldsymbol{y_{t-1}} \odot \boldsymbol{r_t}
///
/// Output Gate
///     .. math::
///         \boldsymbol{o_t} = \
///             g(\mathrm{clip}(W_o \boldsymbol{x_t} + \
///                             R_o \boldsymbol{c_t} + b_o))
///
/// Output
///     .. math::
///         \boldsymbol{y_t} = \
///             (1 - \boldsymbol{z_t}) \odot \boldsymbol{o_t} + \
///              \boldsymbol{z_t} \odot \boldsymbol{y_{t-1}}
///
/// - ``W_z``, ``W_r``, ``W_o`` are 2-dimensional input weight matrices
///   (``[outputVectorSize, inputVectorSize]``, row-major)
/// - ``R_z``, ``R_r``, ``R_o`` are 2-dimensional recursion matrices
///   (``[outputVectorSize, outputVectorSize]``, row-major)
/// - ``b_z``, ``b_r``, ``b_o`` are 1-dimensional bias vectors
///   (``[outputVectorSize]``)
/// - ``f()``, ``g()`` are activations
/// - ``clip()`` is a function that constrains values between ``[-50.0, 50.0]``
/// - ``⊙`` denotes the elementwise product of matrices
struct CoreML_Specification_GRULayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Size of the input vectors.
  var inputVectorSize: UInt64 {
    get {return _storage._inputVectorSize}
    set {_uniqueStorage()._inputVectorSize = newValue}
  }

  //// Size of the output vectors.
  var outputVectorSize: UInt64 {
    get {return _storage._outputVectorSize}
    set {_uniqueStorage()._outputVectorSize = newValue}
  }

  ///*
  /// 2 element array representing activations [f(), g()] in that order.
  /// Typical values used = [sigmoid, tanh].
  /// Activations supported are Linear, Sigmoid, Tanh, ReLU, Scaled Tanh (alpha = 1.71, beta = 2/3), Hard sigmoid (alpha = 0.2, beta = 0.5)
  var activations: [CoreML_Specification_ActivationParams] {
    get {return _storage._activations}
    set {_uniqueStorage()._activations = newValue}
  }

  ///*
  /// If false output is just the result after final state update.
  /// If true, output is a sequence, containing outputs at all time steps.
  var sequenceOutput: Bool {
    get {return _storage._sequenceOutput}
    set {_uniqueStorage()._sequenceOutput = newValue}
  }

  ///*
  /// If false, no biases (``b_z``, ``b_r``, ``b_o``) are added.
  var hasBiasVectors_p: Bool {
    get {return _storage._hasBiasVectors_p}
    set {_uniqueStorage()._hasBiasVectors_p = newValue}
  }

  //// Weight Matrix W_z.
  var updateGateWeightMatrix: CoreML_Specification_WeightParams {
    get {return _storage._updateGateWeightMatrix ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._updateGateWeightMatrix = newValue}
  }
  /// Returns true if `updateGateWeightMatrix` has been explicitly set.
  var hasUpdateGateWeightMatrix: Bool {return _storage._updateGateWeightMatrix != nil}
  /// Clears the value of `updateGateWeightMatrix`. Subsequent reads from it will return its default value.
  mutating func clearUpdateGateWeightMatrix() {_uniqueStorage()._updateGateWeightMatrix = nil}

  //// Weight Matrix W_r.
  var resetGateWeightMatrix: CoreML_Specification_WeightParams {
    get {return _storage._resetGateWeightMatrix ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._resetGateWeightMatrix = newValue}
  }
  /// Returns true if `resetGateWeightMatrix` has been explicitly set.
  var hasResetGateWeightMatrix: Bool {return _storage._resetGateWeightMatrix != nil}
  /// Clears the value of `resetGateWeightMatrix`. Subsequent reads from it will return its default value.
  mutating func clearResetGateWeightMatrix() {_uniqueStorage()._resetGateWeightMatrix = nil}

  //// Weight Matrix W_o.
  var outputGateWeightMatrix: CoreML_Specification_WeightParams {
    get {return _storage._outputGateWeightMatrix ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._outputGateWeightMatrix = newValue}
  }
  /// Returns true if `outputGateWeightMatrix` has been explicitly set.
  var hasOutputGateWeightMatrix: Bool {return _storage._outputGateWeightMatrix != nil}
  /// Clears the value of `outputGateWeightMatrix`. Subsequent reads from it will return its default value.
  mutating func clearOutputGateWeightMatrix() {_uniqueStorage()._outputGateWeightMatrix = nil}

  //// Recursion Weight Matrix R_z.
  var updateGateRecursionMatrix: CoreML_Specification_WeightParams {
    get {return _storage._updateGateRecursionMatrix ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._updateGateRecursionMatrix = newValue}
  }
  /// Returns true if `updateGateRecursionMatrix` has been explicitly set.
  var hasUpdateGateRecursionMatrix: Bool {return _storage._updateGateRecursionMatrix != nil}
  /// Clears the value of `updateGateRecursionMatrix`. Subsequent reads from it will return its default value.
  mutating func clearUpdateGateRecursionMatrix() {_uniqueStorage()._updateGateRecursionMatrix = nil}

  //// Recursion Weight Matrix R_r.
  var resetGateRecursionMatrix: CoreML_Specification_WeightParams {
    get {return _storage._resetGateRecursionMatrix ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._resetGateRecursionMatrix = newValue}
  }
  /// Returns true if `resetGateRecursionMatrix` has been explicitly set.
  var hasResetGateRecursionMatrix: Bool {return _storage._resetGateRecursionMatrix != nil}
  /// Clears the value of `resetGateRecursionMatrix`. Subsequent reads from it will return its default value.
  mutating func clearResetGateRecursionMatrix() {_uniqueStorage()._resetGateRecursionMatrix = nil}

  //// Recursion Weight Matrix R_o.
  var outputGateRecursionMatrix: CoreML_Specification_WeightParams {
    get {return _storage._outputGateRecursionMatrix ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._outputGateRecursionMatrix = newValue}
  }
  /// Returns true if `outputGateRecursionMatrix` has been explicitly set.
  var hasOutputGateRecursionMatrix: Bool {return _storage._outputGateRecursionMatrix != nil}
  /// Clears the value of `outputGateRecursionMatrix`. Subsequent reads from it will return its default value.
  mutating func clearOutputGateRecursionMatrix() {_uniqueStorage()._outputGateRecursionMatrix = nil}

  //// Bias vector b_z.
  var updateGateBiasVector: CoreML_Specification_WeightParams {
    get {return _storage._updateGateBiasVector ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._updateGateBiasVector = newValue}
  }
  /// Returns true if `updateGateBiasVector` has been explicitly set.
  var hasUpdateGateBiasVector: Bool {return _storage._updateGateBiasVector != nil}
  /// Clears the value of `updateGateBiasVector`. Subsequent reads from it will return its default value.
  mutating func clearUpdateGateBiasVector() {_uniqueStorage()._updateGateBiasVector = nil}

  //// Bias vector b_r.
  var resetGateBiasVector: CoreML_Specification_WeightParams {
    get {return _storage._resetGateBiasVector ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._resetGateBiasVector = newValue}
  }
  /// Returns true if `resetGateBiasVector` has been explicitly set.
  var hasResetGateBiasVector: Bool {return _storage._resetGateBiasVector != nil}
  /// Clears the value of `resetGateBiasVector`. Subsequent reads from it will return its default value.
  mutating func clearResetGateBiasVector() {_uniqueStorage()._resetGateBiasVector = nil}

  //// Bias vector b_o.
  var outputGateBiasVector: CoreML_Specification_WeightParams {
    get {return _storage._outputGateBiasVector ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._outputGateBiasVector = newValue}
  }
  /// Returns true if `outputGateBiasVector` has been explicitly set.
  var hasOutputGateBiasVector: Bool {return _storage._outputGateBiasVector != nil}
  /// Clears the value of `outputGateBiasVector`. Subsequent reads from it will return its default value.
  mutating func clearOutputGateBiasVector() {_uniqueStorage()._outputGateBiasVector = nil}

  //// If true, then the node processes the input sequence from right to left
  var reverseInput: Bool {
    get {return _storage._reverseInput}
    set {_uniqueStorage()._reverseInput = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// Long short-term memory (LSTM) parameters.
///
/// This is described by the following equations:
///
/// Input Gate
///     .. math::
///         \boldsymbol{i_t} = \
///             f(\mathrm{clip}(W_i \boldsymbol{x_t} + \
///                             R_i \boldsymbol{y_{t-1}} + \
///                             p_i \odot c_{t-1} + b_i))
///
/// Forget Gate
///     .. math::
///         \boldsymbol{f_t} = \
///             f(\mathrm{clip}(W_f \boldsymbol{x_t} + \
///                             R_f \boldsymbol{y_{t-1}} + \
///                             p_f \odot c_{t-1} + b_f))
///
/// Block Input
///     .. math::
///         \boldsymbol{z_t} = \
///             g(\mathrm{clip}(W_z \boldsymbol{x_t} + \
///                             R_z \boldsymbol{y_{t-1}} + b_z))
///
/// Cell Memory State
///     .. math::
///         \boldsymbol{c_t} = \
///             \boldsymbol{c_{t-1}} \odot \boldsymbol{f_t} + \
///             \boldsymbol{i_t} \odot \boldsymbol{z_t}
///
/// Output Gate
///     .. math::
///         \boldsymbol{o_t} = \
///             f(\mathrm{clip}(W_o \boldsymbol{x_t} + \
///                             R_o \boldsymbol{y_{t-1}} + \
///                             p_o \odot c_t + b_o))
///
/// Output
///     .. math::
///         \boldsymbol{y_t} = \
///             h(\boldsymbol{c_t}) \odot \boldsymbol{o_t}
///
/// - ``W_i``, ``W_f``, ``W_z``, ``W_o`` are 2-dimensional input weight matrices
///   (``[outputVectorSize, inputVectorSize]``, row-major)
/// - ``R_i``, ``R_f``, ``R_z``, ``R_o`` are 2-dimensional recursion matrices
///   (``[outputVectorSize, outputVectorSize]``, row-major)
/// - ``b_i``, ``b_f``, ``b_z``, ``b_o`` are 1-dimensional bias vectors
///   (``[outputVectorSize]``)
/// - ``p_``, ``p_f``, ``p_o`` are 1-dimensional peephole vectors
///   (``[outputVectorSize]``)
/// - ``f()``, ``g()``, ``h()`` are activations
/// - ``clip()`` is a function that constrains values between ``[-50.0, 50.0]``
/// - ``⊙`` denotes the elementwise product of matrices
struct CoreML_Specification_LSTMParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// If true, output is a sequence, containing outputs at all time steps.
  /// If false, output is just the result after final state update.
  var sequenceOutput: Bool = false

  ///*
  /// If false, no biases (``b_i``, ``b_f``, ``b_z``, ``b_o``) are added.
  var hasBiasVectors_p: Bool = false

  ///*
  /// If true, a vector of ``1`` values is added to ``b_f``.
  var forgetBias: Bool = false

  ///*
  /// If true, peephole vectors are included.
  var hasPeepholeVectors_p: Bool = false

  ///*
  /// If the coupled Input and Forget flag is on, the behaviour of
  /// ``c_t`` is changed to the following (i.e. forget gate is not used):
  ///
  /// .. math::
  ///     \boldsymbol{c_t} = \
  ///         \boldsymbol{c_{t-1}} \odot (1 - \boldsymbol{i_t}) + \
  ///         \boldsymbol{i_t} \odot \boldsymbol{z_t}
  var coupledInputAndForgetGate: Bool = false

  ///*
  /// Places a limit on the maximum and minimum values of ``c_t``.
  /// c_t = min(c_t, cellClipThreshold)
  /// c_t = max(c_t, -cellClipThreshold)
  /// If 0, it is set to its default value = 50.0.
  var cellClipThreshold: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// Weights for long short-term memory (LSTM) layers
struct CoreML_Specification_LSTMWeightParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Weight Matrix W_i.
  var inputGateWeightMatrix: CoreML_Specification_WeightParams {
    get {return _storage._inputGateWeightMatrix ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._inputGateWeightMatrix = newValue}
  }
  /// Returns true if `inputGateWeightMatrix` has been explicitly set.
  var hasInputGateWeightMatrix: Bool {return _storage._inputGateWeightMatrix != nil}
  /// Clears the value of `inputGateWeightMatrix`. Subsequent reads from it will return its default value.
  mutating func clearInputGateWeightMatrix() {_uniqueStorage()._inputGateWeightMatrix = nil}

  //// Weight Matrix W_f.
  var forgetGateWeightMatrix: CoreML_Specification_WeightParams {
    get {return _storage._forgetGateWeightMatrix ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._forgetGateWeightMatrix = newValue}
  }
  /// Returns true if `forgetGateWeightMatrix` has been explicitly set.
  var hasForgetGateWeightMatrix: Bool {return _storage._forgetGateWeightMatrix != nil}
  /// Clears the value of `forgetGateWeightMatrix`. Subsequent reads from it will return its default value.
  mutating func clearForgetGateWeightMatrix() {_uniqueStorage()._forgetGateWeightMatrix = nil}

  //// Weight Matrix W_z.
  var blockInputWeightMatrix: CoreML_Specification_WeightParams {
    get {return _storage._blockInputWeightMatrix ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._blockInputWeightMatrix = newValue}
  }
  /// Returns true if `blockInputWeightMatrix` has been explicitly set.
  var hasBlockInputWeightMatrix: Bool {return _storage._blockInputWeightMatrix != nil}
  /// Clears the value of `blockInputWeightMatrix`. Subsequent reads from it will return its default value.
  mutating func clearBlockInputWeightMatrix() {_uniqueStorage()._blockInputWeightMatrix = nil}

  //// Weight Matrix W_o.
  var outputGateWeightMatrix: CoreML_Specification_WeightParams {
    get {return _storage._outputGateWeightMatrix ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._outputGateWeightMatrix = newValue}
  }
  /// Returns true if `outputGateWeightMatrix` has been explicitly set.
  var hasOutputGateWeightMatrix: Bool {return _storage._outputGateWeightMatrix != nil}
  /// Clears the value of `outputGateWeightMatrix`. Subsequent reads from it will return its default value.
  mutating func clearOutputGateWeightMatrix() {_uniqueStorage()._outputGateWeightMatrix = nil}

  //// Recursion Weight Matrix R_i.
  var inputGateRecursionMatrix: CoreML_Specification_WeightParams {
    get {return _storage._inputGateRecursionMatrix ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._inputGateRecursionMatrix = newValue}
  }
  /// Returns true if `inputGateRecursionMatrix` has been explicitly set.
  var hasInputGateRecursionMatrix: Bool {return _storage._inputGateRecursionMatrix != nil}
  /// Clears the value of `inputGateRecursionMatrix`. Subsequent reads from it will return its default value.
  mutating func clearInputGateRecursionMatrix() {_uniqueStorage()._inputGateRecursionMatrix = nil}

  //// Recursion Weight Matrix R_f.
  var forgetGateRecursionMatrix: CoreML_Specification_WeightParams {
    get {return _storage._forgetGateRecursionMatrix ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._forgetGateRecursionMatrix = newValue}
  }
  /// Returns true if `forgetGateRecursionMatrix` has been explicitly set.
  var hasForgetGateRecursionMatrix: Bool {return _storage._forgetGateRecursionMatrix != nil}
  /// Clears the value of `forgetGateRecursionMatrix`. Subsequent reads from it will return its default value.
  mutating func clearForgetGateRecursionMatrix() {_uniqueStorage()._forgetGateRecursionMatrix = nil}

  //// Recursion Weight Matrix R_z.
  var blockInputRecursionMatrix: CoreML_Specification_WeightParams {
    get {return _storage._blockInputRecursionMatrix ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._blockInputRecursionMatrix = newValue}
  }
  /// Returns true if `blockInputRecursionMatrix` has been explicitly set.
  var hasBlockInputRecursionMatrix: Bool {return _storage._blockInputRecursionMatrix != nil}
  /// Clears the value of `blockInputRecursionMatrix`. Subsequent reads from it will return its default value.
  mutating func clearBlockInputRecursionMatrix() {_uniqueStorage()._blockInputRecursionMatrix = nil}

  //// Recursion Weight Matrix R_o.
  var outputGateRecursionMatrix: CoreML_Specification_WeightParams {
    get {return _storage._outputGateRecursionMatrix ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._outputGateRecursionMatrix = newValue}
  }
  /// Returns true if `outputGateRecursionMatrix` has been explicitly set.
  var hasOutputGateRecursionMatrix: Bool {return _storage._outputGateRecursionMatrix != nil}
  /// Clears the value of `outputGateRecursionMatrix`. Subsequent reads from it will return its default value.
  mutating func clearOutputGateRecursionMatrix() {_uniqueStorage()._outputGateRecursionMatrix = nil}

  ///biases:
  var inputGateBiasVector: CoreML_Specification_WeightParams {
    get {return _storage._inputGateBiasVector ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._inputGateBiasVector = newValue}
  }
  /// Returns true if `inputGateBiasVector` has been explicitly set.
  var hasInputGateBiasVector: Bool {return _storage._inputGateBiasVector != nil}
  /// Clears the value of `inputGateBiasVector`. Subsequent reads from it will return its default value.
  mutating func clearInputGateBiasVector() {_uniqueStorage()._inputGateBiasVector = nil}

  //// Bias vector b_f.
  var forgetGateBiasVector: CoreML_Specification_WeightParams {
    get {return _storage._forgetGateBiasVector ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._forgetGateBiasVector = newValue}
  }
  /// Returns true if `forgetGateBiasVector` has been explicitly set.
  var hasForgetGateBiasVector: Bool {return _storage._forgetGateBiasVector != nil}
  /// Clears the value of `forgetGateBiasVector`. Subsequent reads from it will return its default value.
  mutating func clearForgetGateBiasVector() {_uniqueStorage()._forgetGateBiasVector = nil}

  //// Bias vector b_z.
  var blockInputBiasVector: CoreML_Specification_WeightParams {
    get {return _storage._blockInputBiasVector ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._blockInputBiasVector = newValue}
  }
  /// Returns true if `blockInputBiasVector` has been explicitly set.
  var hasBlockInputBiasVector: Bool {return _storage._blockInputBiasVector != nil}
  /// Clears the value of `blockInputBiasVector`. Subsequent reads from it will return its default value.
  mutating func clearBlockInputBiasVector() {_uniqueStorage()._blockInputBiasVector = nil}

  //// Bias vector b_o.
  var outputGateBiasVector: CoreML_Specification_WeightParams {
    get {return _storage._outputGateBiasVector ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._outputGateBiasVector = newValue}
  }
  /// Returns true if `outputGateBiasVector` has been explicitly set.
  var hasOutputGateBiasVector: Bool {return _storage._outputGateBiasVector != nil}
  /// Clears the value of `outputGateBiasVector`. Subsequent reads from it will return its default value.
  mutating func clearOutputGateBiasVector() {_uniqueStorage()._outputGateBiasVector = nil}

  ///peepholes:
  var inputGatePeepholeVector: CoreML_Specification_WeightParams {
    get {return _storage._inputGatePeepholeVector ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._inputGatePeepholeVector = newValue}
  }
  /// Returns true if `inputGatePeepholeVector` has been explicitly set.
  var hasInputGatePeepholeVector: Bool {return _storage._inputGatePeepholeVector != nil}
  /// Clears the value of `inputGatePeepholeVector`. Subsequent reads from it will return its default value.
  mutating func clearInputGatePeepholeVector() {_uniqueStorage()._inputGatePeepholeVector = nil}

  //// Peephole vector p_f.
  var forgetGatePeepholeVector: CoreML_Specification_WeightParams {
    get {return _storage._forgetGatePeepholeVector ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._forgetGatePeepholeVector = newValue}
  }
  /// Returns true if `forgetGatePeepholeVector` has been explicitly set.
  var hasForgetGatePeepholeVector: Bool {return _storage._forgetGatePeepholeVector != nil}
  /// Clears the value of `forgetGatePeepholeVector`. Subsequent reads from it will return its default value.
  mutating func clearForgetGatePeepholeVector() {_uniqueStorage()._forgetGatePeepholeVector = nil}

  //// Peephole vector p_o.
  var outputGatePeepholeVector: CoreML_Specification_WeightParams {
    get {return _storage._outputGatePeepholeVector ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._outputGatePeepholeVector = newValue}
  }
  /// Returns true if `outputGatePeepholeVector` has been explicitly set.
  var hasOutputGatePeepholeVector: Bool {return _storage._outputGatePeepholeVector != nil}
  /// Clears the value of `outputGatePeepholeVector`. Subsequent reads from it will return its default value.
  mutating func clearOutputGatePeepholeVector() {_uniqueStorage()._outputGatePeepholeVector = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A unidirectional long short-term memory (LSTM) layer.
///
/// .. code::
///
///      (y_t, c_t) = UniDirectionalLSTMLayer(x_t, y_{t-1}, c_{t-1})
///
/// Input
///    A sequence of vectors of size ``inputVectorSize``
///    with shape ``[Seq, inputVectorSize]``.
/// Output
///    A vector of size ``outputVectorSize``. It is either the final output or a sequence of outputs at all time steps.
///
/// - Output Shape: ``[1,outputVectorSize]`` , if ``sequenceOutput == false``
/// - Output Shape: ``[Seq,outputVectorSize]`` , if ``sequenceOutput == true``
struct CoreML_Specification_UniDirectionalLSTMLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Size of the input vectors.
  var inputVectorSize: UInt64 {
    get {return _storage._inputVectorSize}
    set {_uniqueStorage()._inputVectorSize = newValue}
  }

  //// Size of the output vectors.
  var outputVectorSize: UInt64 {
    get {return _storage._outputVectorSize}
    set {_uniqueStorage()._outputVectorSize = newValue}
  }

  ///*
  /// 3 element array representing activations [f(),g(),h()] in that order.
  /// Typical values used = [sigmoid, tanh, tanh].
  /// Activations supported are Linear, Sigmoid, Tanh, ReLU, Scaled Tanh (alpha = 1.71, beta = 2/3), Hard sigmoid (alpha = 0.2, beta = 0.5)
  var activations: [CoreML_Specification_ActivationParams] {
    get {return _storage._activations}
    set {_uniqueStorage()._activations = newValue}
  }

  var params: CoreML_Specification_LSTMParams {
    get {return _storage._params ?? CoreML_Specification_LSTMParams()}
    set {_uniqueStorage()._params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return _storage._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {_uniqueStorage()._params = nil}

  //// Weights, biases and peepholes.
  var weightParams: CoreML_Specification_LSTMWeightParams {
    get {return _storage._weightParams ?? CoreML_Specification_LSTMWeightParams()}
    set {_uniqueStorage()._weightParams = newValue}
  }
  /// Returns true if `weightParams` has been explicitly set.
  var hasWeightParams: Bool {return _storage._weightParams != nil}
  /// Clears the value of `weightParams`. Subsequent reads from it will return its default value.
  mutating func clearWeightParams() {_uniqueStorage()._weightParams = nil}

  //// If true, then the node processes the input sequence from right to left
  var reverseInput: Bool {
    get {return _storage._reverseInput}
    set {_uniqueStorage()._reverseInput = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// Bidirectional long short-term memory (LSTM) layer
///
/// .. code::
///
///      (y_t, c_t, y_t_reverse, c_t_reverse) = BiDirectionalLSTMLayer(x_t, y_{t-1}, c_{t-1}, y_{t-1}_reverse, c_{t-1}_reverse)
///
/// Input
///    A sequence of vectors of size ``inputVectorSize``
///    with shape ``[Seq, inputVectorSize]``.
/// Output
///    A vector of size ``2 * outputVectorSize``. It is either the final output or a sequence of outputs at all time steps.
///
/// - Output Shape: ``[1, 2 * outputVectorSize]`` , if ``sequenceOutput == false``
/// - Output Shape: ``[Seq, 2 * outputVectorSize]`` , if ``sequenceOutput == true``
///
/// The first LSTM operates on the input sequence in the forward direction.
/// The second LSTM operates on the input sequence in the reverse direction.
///
/// Example: given the input sequence ``[x_1, x_2, x_3]``,
/// where ``x_i`` are vectors at time index ``i``:
///
/// The forward LSTM output is ``[yf_1, yf_2, yf_3]``,
///
/// where ``yf_i`` are vectors of size ``outputVectorSize``:
///
/// - ``yf_1`` is the output at the end of sequence {``x_1``}
/// - ``yf_2`` is the output at the end of sequence {``x_1``, ``x_2``}
/// - ``yf_3`` is the output at the end of sequence {``x_1``, ``x_2``, ``x_3``}
///
/// The backward LSTM output: ``[yb_1, yb_2, yb_3]``,
///
/// where ``yb_i`` are vectors of size ``outputVectorSize``:
///
/// - ``yb_1`` is the output at the end of sequence {``x_3``}
/// - ``yb_2`` is the output at the end of sequence {``x_3``, ``x_2``}
/// - ``yb_3`` is the output at the end of sequence {``x_3``, ``x_2``, ``x_1``}
///
/// Output of the bi-dir layer:
///
/// - if ``sequenceOutput = True`` : { ``[yf_1, yb_3]``,  ``[yf_2, yb_2]``,  ``[yf_3, yb_1]`` }
/// - if ``sequenceOutput = False`` : { ``[yf_3, yb_3]`` }
struct CoreML_Specification_BiDirectionalLSTMLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// Size of the input vectors.
  var inputVectorSize: UInt64 {
    get {return _storage._inputVectorSize}
    set {_uniqueStorage()._inputVectorSize = newValue}
  }

  ///*
  /// Size of the outputs vectors.
  /// It is same for both forward and backward LSTMs.
  var outputVectorSize: UInt64 {
    get {return _storage._outputVectorSize}
    set {_uniqueStorage()._outputVectorSize = newValue}
  }

  ///*
  /// 3 element array representing activations [f(),g(),h()] in that order.
  /// Typical values used = [sigmoid, tanh, tanh].
  /// Activations supported are Linear, Sigmoid, Tanh, ReLU, Scaled Tanh (alpha = 1.71, beta = 2/3), Hard sigmoid (alpha = 0.2, beta = 0.5)
  var activationsForwardLstm: [CoreML_Specification_ActivationParams] {
    get {return _storage._activationsForwardLstm}
    set {_uniqueStorage()._activationsForwardLstm = newValue}
  }

  ///*
  /// Currently, backward LSTM activations
  /// must be same as the ones for the forward LSTM.
  var activationsBackwardLstm: [CoreML_Specification_ActivationParams] {
    get {return _storage._activationsBackwardLstm}
    set {_uniqueStorage()._activationsBackwardLstm = newValue}
  }

  ///*
  /// Common parameters shared by the forward and backward LSTMs.
  var params: CoreML_Specification_LSTMParams {
    get {return _storage._params ?? CoreML_Specification_LSTMParams()}
    set {_uniqueStorage()._params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return _storage._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {_uniqueStorage()._params = nil}

  ///*
  /// Weights and biases.
  /// Must be a length 2 message,
  /// for the forward and backward LSTM respectively.
  var weightParams: [CoreML_Specification_LSTMWeightParams] {
    get {return _storage._weightParams}
    set {_uniqueStorage()._weightParams = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct CoreML_Specification_CustomLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the class (conforming to MLCustomLayer) corresponding to this layer
  var className: String = String()

  /// Any weights -- these are serialized in binary format and memmapped at runtime
  var weights: [CoreML_Specification_WeightParams] = []

  /// these may be handled as strings, so this should not be large
  var parameters: Dictionary<String,CoreML_Specification_CustomLayerParams.CustomLayerParamValue> = [:]

  /// An (optional) description of the layer provided by the model creator. This information is displayed when viewing the model, but does not affect the model's execution on device.
  var description_p: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct CustomLayerParamValue {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: CoreML_Specification_CustomLayerParams.CustomLayerParamValue.OneOf_Value? = nil

    var doubleValue: Double {
      get {
        if case .doubleValue(let v)? = value {return v}
        return 0
      }
      set {value = .doubleValue(newValue)}
    }

    var stringValue: String {
      get {
        if case .stringValue(let v)? = value {return v}
        return String()
      }
      set {value = .stringValue(newValue)}
    }

    var intValue: Int32 {
      get {
        if case .intValue(let v)? = value {return v}
        return 0
      }
      set {value = .intValue(newValue)}
    }

    var longValue: Int64 {
      get {
        if case .longValue(let v)? = value {return v}
        return 0
      }
      set {value = .longValue(newValue)}
    }

    var boolValue: Bool {
      get {
        if case .boolValue(let v)? = value {return v}
        return false
      }
      set {value = .boolValue(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Value: Equatable {
      case doubleValue(Double)
      case stringValue(String)
      case intValue(Int32)
      case longValue(Int64)
      case boolValue(Bool)

    #if !swift(>=4.1)
      static func ==(lhs: CoreML_Specification_CustomLayerParams.CustomLayerParamValue.OneOf_Value, rhs: CoreML_Specification_CustomLayerParams.CustomLayerParamValue.OneOf_Value) -> Bool {
        switch (lhs, rhs) {
        case (.doubleValue(let l), .doubleValue(let r)): return l == r
        case (.stringValue(let l), .stringValue(let r)): return l == r
        case (.intValue(let l), .intValue(let r)): return l == r
        case (.longValue(let l), .longValue(let r)): return l == r
        case (.boolValue(let l), .boolValue(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    init() {}
  }

  init() {}
}

///*
/// A neural network specialized as a classifier.
struct CoreML_Specification_NeuralNetworkClassifier {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var layers: [CoreML_Specification_NeuralNetworkLayer] {
    get {return _storage._layers}
    set {_uniqueStorage()._layers = newValue}
  }

  var preprocessing: [CoreML_Specification_NeuralNetworkPreprocessing] {
    get {return _storage._preprocessing}
    set {_uniqueStorage()._preprocessing = newValue}
  }

  ///*
  /// Mapping from indexed vector of probabilities to class label
  var classLabels: OneOf_ClassLabels? {
    get {return _storage._classLabels}
    set {_uniqueStorage()._classLabels = newValue}
  }

  var stringClassLabels: CoreML_Specification_StringVector {
    get {
      if case .stringClassLabels(let v)? = _storage._classLabels {return v}
      return CoreML_Specification_StringVector()
    }
    set {_uniqueStorage()._classLabels = .stringClassLabels(newValue)}
  }

  var int64ClassLabels: CoreML_Specification_Int64Vector {
    get {
      if case .int64ClassLabels(let v)? = _storage._classLabels {return v}
      return CoreML_Specification_Int64Vector()
    }
    set {_uniqueStorage()._classLabels = .int64ClassLabels(newValue)}
  }

  ///*
  /// The name of the output blob which will be used as the predicted
  /// probabilities of each class label.
  var labelProbabilityLayerName: String {
    get {return _storage._labelProbabilityLayerName}
    set {_uniqueStorage()._labelProbabilityLayerName = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///*
  /// Mapping from indexed vector of probabilities to class label
  enum OneOf_ClassLabels: Equatable {
    case stringClassLabels(CoreML_Specification_StringVector)
    case int64ClassLabels(CoreML_Specification_Int64Vector)

  #if !swift(>=4.1)
    static func ==(lhs: CoreML_Specification_NeuralNetworkClassifier.OneOf_ClassLabels, rhs: CoreML_Specification_NeuralNetworkClassifier.OneOf_ClassLabels) -> Bool {
      switch (lhs, rhs) {
      case (.stringClassLabels(let l), .stringClassLabels(let r)): return l == r
      case (.int64ClassLabels(let l), .int64ClassLabels(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A neural network specialized as a regressor.
struct CoreML_Specification_NeuralNetworkRegressor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var layers: [CoreML_Specification_NeuralNetworkLayer] = []

  var preprocessing: [CoreML_Specification_NeuralNetworkPreprocessing] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "CoreML.Specification"

extension CoreML_Specification_NeuralNetwork: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NeuralNetwork"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "layers"),
    2: .same(proto: "preprocessing"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.layers)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.preprocessing)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.layers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.layers, fieldNumber: 1)
    }
    if !self.preprocessing.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.preprocessing, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_NeuralNetwork, rhs: CoreML_Specification_NeuralNetwork) -> Bool {
    if lhs.layers != rhs.layers {return false}
    if lhs.preprocessing != rhs.preprocessing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_NeuralNetworkImageScaler: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NeuralNetworkImageScaler"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    10: .same(proto: "channelScale"),
    20: .same(proto: "blueBias"),
    21: .same(proto: "greenBias"),
    22: .same(proto: "redBias"),
    30: .same(proto: "grayBias"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 10: try decoder.decodeSingularFloatField(value: &self.channelScale)
      case 20: try decoder.decodeSingularFloatField(value: &self.blueBias)
      case 21: try decoder.decodeSingularFloatField(value: &self.greenBias)
      case 22: try decoder.decodeSingularFloatField(value: &self.redBias)
      case 30: try decoder.decodeSingularFloatField(value: &self.grayBias)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.channelScale != 0 {
      try visitor.visitSingularFloatField(value: self.channelScale, fieldNumber: 10)
    }
    if self.blueBias != 0 {
      try visitor.visitSingularFloatField(value: self.blueBias, fieldNumber: 20)
    }
    if self.greenBias != 0 {
      try visitor.visitSingularFloatField(value: self.greenBias, fieldNumber: 21)
    }
    if self.redBias != 0 {
      try visitor.visitSingularFloatField(value: self.redBias, fieldNumber: 22)
    }
    if self.grayBias != 0 {
      try visitor.visitSingularFloatField(value: self.grayBias, fieldNumber: 30)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_NeuralNetworkImageScaler, rhs: CoreML_Specification_NeuralNetworkImageScaler) -> Bool {
    if lhs.channelScale != rhs.channelScale {return false}
    if lhs.blueBias != rhs.blueBias {return false}
    if lhs.greenBias != rhs.greenBias {return false}
    if lhs.redBias != rhs.redBias {return false}
    if lhs.grayBias != rhs.grayBias {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_NeuralNetworkMeanImage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NeuralNetworkMeanImage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "meanImage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedFloatField(value: &self.meanImage)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.meanImage.isEmpty {
      try visitor.visitPackedFloatField(value: self.meanImage, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_NeuralNetworkMeanImage, rhs: CoreML_Specification_NeuralNetworkMeanImage) -> Bool {
    if lhs.meanImage != rhs.meanImage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_NeuralNetworkPreprocessing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NeuralNetworkPreprocessing"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "featureName"),
    10: .same(proto: "scaler"),
    11: .same(proto: "meanImage"),
  ]

  fileprivate class _StorageClass {
    var _featureName: String = String()
    var _preprocessor: CoreML_Specification_NeuralNetworkPreprocessing.OneOf_Preprocessor?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _featureName = source._featureName
      _preprocessor = source._preprocessor
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._featureName)
        case 10:
          var v: CoreML_Specification_NeuralNetworkImageScaler?
          if let current = _storage._preprocessor {
            try decoder.handleConflictingOneOf()
            if case .scaler(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._preprocessor = .scaler(v)}
        case 11:
          var v: CoreML_Specification_NeuralNetworkMeanImage?
          if let current = _storage._preprocessor {
            try decoder.handleConflictingOneOf()
            if case .meanImage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._preprocessor = .meanImage(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._featureName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._featureName, fieldNumber: 1)
      }
      switch _storage._preprocessor {
      case .scaler(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .meanImage(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_NeuralNetworkPreprocessing, rhs: CoreML_Specification_NeuralNetworkPreprocessing) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._featureName != rhs_storage._featureName {return false}
        if _storage._preprocessor != rhs_storage._preprocessor {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ActivationReLU: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivationReLU"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_ActivationReLU, rhs: CoreML_Specification_ActivationReLU) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ActivationLeakyReLU: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivationLeakyReLU"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.alpha)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_ActivationLeakyReLU, rhs: CoreML_Specification_ActivationLeakyReLU) -> Bool {
    if lhs.alpha != rhs.alpha {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ActivationTanh: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivationTanh"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_ActivationTanh, rhs: CoreML_Specification_ActivationTanh) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ActivationScaledTanh: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivationScaledTanh"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
    2: .same(proto: "beta"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.alpha)
      case 2: try decoder.decodeSingularFloatField(value: &self.beta)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 1)
    }
    if self.beta != 0 {
      try visitor.visitSingularFloatField(value: self.beta, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_ActivationScaledTanh, rhs: CoreML_Specification_ActivationScaledTanh) -> Bool {
    if lhs.alpha != rhs.alpha {return false}
    if lhs.beta != rhs.beta {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ActivationSigmoid: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivationSigmoid"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_ActivationSigmoid, rhs: CoreML_Specification_ActivationSigmoid) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ActivationLinear: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivationLinear"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
    2: .same(proto: "beta"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.alpha)
      case 2: try decoder.decodeSingularFloatField(value: &self.beta)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 1)
    }
    if self.beta != 0 {
      try visitor.visitSingularFloatField(value: self.beta, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_ActivationLinear, rhs: CoreML_Specification_ActivationLinear) -> Bool {
    if lhs.alpha != rhs.alpha {return false}
    if lhs.beta != rhs.beta {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ActivationSigmoidHard: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivationSigmoidHard"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
    2: .same(proto: "beta"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.alpha)
      case 2: try decoder.decodeSingularFloatField(value: &self.beta)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 1)
    }
    if self.beta != 0 {
      try visitor.visitSingularFloatField(value: self.beta, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_ActivationSigmoidHard, rhs: CoreML_Specification_ActivationSigmoidHard) -> Bool {
    if lhs.alpha != rhs.alpha {return false}
    if lhs.beta != rhs.beta {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ActivationPReLU: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivationPReLU"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
  ]

  fileprivate class _StorageClass {
    var _alpha: CoreML_Specification_WeightParams? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _alpha = source._alpha
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._alpha)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._alpha {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_ActivationPReLU, rhs: CoreML_Specification_ActivationPReLU) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._alpha != rhs_storage._alpha {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ActivationELU: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivationELU"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.alpha)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_ActivationELU, rhs: CoreML_Specification_ActivationELU) -> Bool {
    if lhs.alpha != rhs.alpha {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ActivationThresholdedReLU: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivationThresholdedReLU"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.alpha)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_ActivationThresholdedReLU, rhs: CoreML_Specification_ActivationThresholdedReLU) -> Bool {
    if lhs.alpha != rhs.alpha {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ActivationSoftsign: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivationSoftsign"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_ActivationSoftsign, rhs: CoreML_Specification_ActivationSoftsign) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ActivationSoftplus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivationSoftplus"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_ActivationSoftplus, rhs: CoreML_Specification_ActivationSoftplus) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ActivationParametricSoftplus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivationParametricSoftplus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
    2: .same(proto: "beta"),
  ]

  fileprivate class _StorageClass {
    var _alpha: CoreML_Specification_WeightParams? = nil
    var _beta: CoreML_Specification_WeightParams? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _alpha = source._alpha
      _beta = source._beta
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._alpha)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._beta)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._alpha {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._beta {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_ActivationParametricSoftplus, rhs: CoreML_Specification_ActivationParametricSoftplus) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._alpha != rhs_storage._alpha {return false}
        if _storage._beta != rhs_storage._beta {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ActivationParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivationParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .same(proto: "linear"),
    10: .same(proto: "ReLU"),
    15: .same(proto: "leakyReLU"),
    20: .same(proto: "thresholdedReLU"),
    25: .same(proto: "PReLU"),
    30: .same(proto: "tanh"),
    31: .same(proto: "scaledTanh"),
    40: .same(proto: "sigmoid"),
    41: .same(proto: "sigmoidHard"),
    50: .same(proto: "ELU"),
    60: .same(proto: "softsign"),
    70: .same(proto: "softplus"),
    71: .same(proto: "parametricSoftplus"),
  ]

  fileprivate class _StorageClass {
    var _nonlinearityType: CoreML_Specification_ActivationParams.OneOf_NonlinearityType?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _nonlinearityType = source._nonlinearityType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 5:
          var v: CoreML_Specification_ActivationLinear?
          if let current = _storage._nonlinearityType {
            try decoder.handleConflictingOneOf()
            if case .linear(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._nonlinearityType = .linear(v)}
        case 10:
          var v: CoreML_Specification_ActivationReLU?
          if let current = _storage._nonlinearityType {
            try decoder.handleConflictingOneOf()
            if case .reLu(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._nonlinearityType = .reLu(v)}
        case 15:
          var v: CoreML_Specification_ActivationLeakyReLU?
          if let current = _storage._nonlinearityType {
            try decoder.handleConflictingOneOf()
            if case .leakyReLu(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._nonlinearityType = .leakyReLu(v)}
        case 20:
          var v: CoreML_Specification_ActivationThresholdedReLU?
          if let current = _storage._nonlinearityType {
            try decoder.handleConflictingOneOf()
            if case .thresholdedReLu(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._nonlinearityType = .thresholdedReLu(v)}
        case 25:
          var v: CoreML_Specification_ActivationPReLU?
          if let current = _storage._nonlinearityType {
            try decoder.handleConflictingOneOf()
            if case .preLu(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._nonlinearityType = .preLu(v)}
        case 30:
          var v: CoreML_Specification_ActivationTanh?
          if let current = _storage._nonlinearityType {
            try decoder.handleConflictingOneOf()
            if case .tanh(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._nonlinearityType = .tanh(v)}
        case 31:
          var v: CoreML_Specification_ActivationScaledTanh?
          if let current = _storage._nonlinearityType {
            try decoder.handleConflictingOneOf()
            if case .scaledTanh(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._nonlinearityType = .scaledTanh(v)}
        case 40:
          var v: CoreML_Specification_ActivationSigmoid?
          if let current = _storage._nonlinearityType {
            try decoder.handleConflictingOneOf()
            if case .sigmoid(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._nonlinearityType = .sigmoid(v)}
        case 41:
          var v: CoreML_Specification_ActivationSigmoidHard?
          if let current = _storage._nonlinearityType {
            try decoder.handleConflictingOneOf()
            if case .sigmoidHard(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._nonlinearityType = .sigmoidHard(v)}
        case 50:
          var v: CoreML_Specification_ActivationELU?
          if let current = _storage._nonlinearityType {
            try decoder.handleConflictingOneOf()
            if case .elu(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._nonlinearityType = .elu(v)}
        case 60:
          var v: CoreML_Specification_ActivationSoftsign?
          if let current = _storage._nonlinearityType {
            try decoder.handleConflictingOneOf()
            if case .softsign(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._nonlinearityType = .softsign(v)}
        case 70:
          var v: CoreML_Specification_ActivationSoftplus?
          if let current = _storage._nonlinearityType {
            try decoder.handleConflictingOneOf()
            if case .softplus(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._nonlinearityType = .softplus(v)}
        case 71:
          var v: CoreML_Specification_ActivationParametricSoftplus?
          if let current = _storage._nonlinearityType {
            try decoder.handleConflictingOneOf()
            if case .parametricSoftplus(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._nonlinearityType = .parametricSoftplus(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._nonlinearityType {
      case .linear(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .reLu(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .leakyReLu(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .thresholdedReLu(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      case .preLu(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      case .tanh(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      case .scaledTanh(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      case .sigmoid(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
      case .sigmoidHard(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
      case .elu(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      case .softsign(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 60)
      case .softplus(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 70)
      case .parametricSoftplus(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 71)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_ActivationParams, rhs: CoreML_Specification_ActivationParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._nonlinearityType != rhs_storage._nonlinearityType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_NeuralNetworkLayer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NeuralNetworkLayer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "input"),
    3: .same(proto: "output"),
    100: .same(proto: "convolution"),
    120: .same(proto: "pooling"),
    130: .same(proto: "activation"),
    140: .same(proto: "innerProduct"),
    150: .same(proto: "embedding"),
    160: .same(proto: "batchnorm"),
    165: .same(proto: "mvn"),
    170: .same(proto: "l2normalize"),
    175: .same(proto: "softmax"),
    180: .same(proto: "lrn"),
    190: .same(proto: "crop"),
    200: .same(proto: "padding"),
    210: .same(proto: "upsample"),
    211: .same(proto: "resizeBilinear"),
    212: .same(proto: "cropResize"),
    220: .same(proto: "unary"),
    230: .same(proto: "add"),
    231: .same(proto: "multiply"),
    240: .same(proto: "average"),
    245: .same(proto: "scale"),
    250: .same(proto: "bias"),
    260: .same(proto: "max"),
    261: .same(proto: "min"),
    270: .same(proto: "dot"),
    280: .same(proto: "reduce"),
    290: .same(proto: "loadConstant"),
    300: .same(proto: "reshape"),
    301: .same(proto: "flatten"),
    310: .same(proto: "permute"),
    320: .same(proto: "concat"),
    330: .same(proto: "split"),
    340: .same(proto: "sequenceRepeat"),
    345: .same(proto: "reorganizeData"),
    350: .same(proto: "slice"),
    400: .same(proto: "simpleRecurrent"),
    410: .same(proto: "gru"),
    420: .same(proto: "uniDirectionalLSTM"),
    430: .same(proto: "biDirectionalLSTM"),
    500: .same(proto: "custom"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _input: [String] = []
    var _output: [String] = []
    var _layer: CoreML_Specification_NeuralNetworkLayer.OneOf_Layer?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _input = source._input
      _output = source._output
      _layer = source._layer
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeRepeatedStringField(value: &_storage._input)
        case 3: try decoder.decodeRepeatedStringField(value: &_storage._output)
        case 100:
          var v: CoreML_Specification_ConvolutionLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .convolution(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .convolution(v)}
        case 120:
          var v: CoreML_Specification_PoolingLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .pooling(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .pooling(v)}
        case 130:
          var v: CoreML_Specification_ActivationParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .activation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .activation(v)}
        case 140:
          var v: CoreML_Specification_InnerProductLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .innerProduct(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .innerProduct(v)}
        case 150:
          var v: CoreML_Specification_EmbeddingLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .embedding(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .embedding(v)}
        case 160:
          var v: CoreML_Specification_BatchnormLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .batchnorm(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .batchnorm(v)}
        case 165:
          var v: CoreML_Specification_MeanVarianceNormalizeLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .mvn(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .mvn(v)}
        case 170:
          var v: CoreML_Specification_L2NormalizeLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .l2Normalize(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .l2Normalize(v)}
        case 175:
          var v: CoreML_Specification_SoftmaxLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .softmax(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .softmax(v)}
        case 180:
          var v: CoreML_Specification_LRNLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .lrn(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .lrn(v)}
        case 190:
          var v: CoreML_Specification_CropLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .crop(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .crop(v)}
        case 200:
          var v: CoreML_Specification_PaddingLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .padding(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .padding(v)}
        case 210:
          var v: CoreML_Specification_UpsampleLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .upsample(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .upsample(v)}
        case 211:
          var v: CoreML_Specification_ResizeBilinearLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .resizeBilinear(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .resizeBilinear(v)}
        case 212:
          var v: CoreML_Specification_CropResizeLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .cropResize(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .cropResize(v)}
        case 220:
          var v: CoreML_Specification_UnaryFunctionLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .unary(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .unary(v)}
        case 230:
          var v: CoreML_Specification_AddLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .add(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .add(v)}
        case 231:
          var v: CoreML_Specification_MultiplyLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .multiply(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .multiply(v)}
        case 240:
          var v: CoreML_Specification_AverageLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .average(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .average(v)}
        case 245:
          var v: CoreML_Specification_ScaleLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .scale(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .scale(v)}
        case 250:
          var v: CoreML_Specification_BiasLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .bias(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .bias(v)}
        case 260:
          var v: CoreML_Specification_MaxLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .max(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .max(v)}
        case 261:
          var v: CoreML_Specification_MinLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .min(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .min(v)}
        case 270:
          var v: CoreML_Specification_DotProductLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .dot(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .dot(v)}
        case 280:
          var v: CoreML_Specification_ReduceLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .reduce(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .reduce(v)}
        case 290:
          var v: CoreML_Specification_LoadConstantLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .loadConstant(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .loadConstant(v)}
        case 300:
          var v: CoreML_Specification_ReshapeLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .reshape(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .reshape(v)}
        case 301:
          var v: CoreML_Specification_FlattenLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .flatten(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .flatten(v)}
        case 310:
          var v: CoreML_Specification_PermuteLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .permute(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .permute(v)}
        case 320:
          var v: CoreML_Specification_ConcatLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .concat(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .concat(v)}
        case 330:
          var v: CoreML_Specification_SplitLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .split(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .split(v)}
        case 340:
          var v: CoreML_Specification_SequenceRepeatLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .sequenceRepeat(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .sequenceRepeat(v)}
        case 345:
          var v: CoreML_Specification_ReorganizeDataLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .reorganizeData(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .reorganizeData(v)}
        case 350:
          var v: CoreML_Specification_SliceLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .slice(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .slice(v)}
        case 400:
          var v: CoreML_Specification_SimpleRecurrentLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .simpleRecurrent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .simpleRecurrent(v)}
        case 410:
          var v: CoreML_Specification_GRULayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .gru(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .gru(v)}
        case 420:
          var v: CoreML_Specification_UniDirectionalLSTMLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .uniDirectionalLstm(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .uniDirectionalLstm(v)}
        case 430:
          var v: CoreML_Specification_BiDirectionalLSTMLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .biDirectionalLstm(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .biDirectionalLstm(v)}
        case 500:
          var v: CoreML_Specification_CustomLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .custom(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .custom(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._input.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._input, fieldNumber: 2)
      }
      if !_storage._output.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._output, fieldNumber: 3)
      }
      switch _storage._layer {
      case .convolution(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
      case .pooling(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 120)
      case .activation(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 130)
      case .innerProduct(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 140)
      case .embedding(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 150)
      case .batchnorm(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 160)
      case .mvn(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 165)
      case .l2Normalize(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 170)
      case .softmax(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 175)
      case .lrn(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 180)
      case .crop(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 190)
      case .padding(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 200)
      case .upsample(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 210)
      case .resizeBilinear(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 211)
      case .cropResize(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 212)
      case .unary(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 220)
      case .add(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 230)
      case .multiply(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 231)
      case .average(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 240)
      case .scale(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 245)
      case .bias(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 250)
      case .max(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 260)
      case .min(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 261)
      case .dot(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 270)
      case .reduce(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 280)
      case .loadConstant(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 290)
      case .reshape(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 300)
      case .flatten(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 301)
      case .permute(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 310)
      case .concat(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 320)
      case .split(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 330)
      case .sequenceRepeat(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 340)
      case .reorganizeData(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 345)
      case .slice(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 350)
      case .simpleRecurrent(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 400)
      case .gru(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 410)
      case .uniDirectionalLstm(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 420)
      case .biDirectionalLstm(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 430)
      case .custom(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 500)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_NeuralNetworkLayer, rhs: CoreML_Specification_NeuralNetworkLayer) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._output != rhs_storage._output {return false}
        if _storage._layer != rhs_storage._layer {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_BorderAmounts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BorderAmounts"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    10: .same(proto: "borderAmounts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 10: try decoder.decodeRepeatedMessageField(value: &self.borderAmounts)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.borderAmounts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.borderAmounts, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_BorderAmounts, rhs: CoreML_Specification_BorderAmounts) -> Bool {
    if lhs.borderAmounts != rhs.borderAmounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_BorderAmounts.EdgeSizes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CoreML_Specification_BorderAmounts.protoMessageName + ".EdgeSizes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "startEdgeSize"),
    2: .same(proto: "endEdgeSize"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.startEdgeSize)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.endEdgeSize)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startEdgeSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.startEdgeSize, fieldNumber: 1)
    }
    if self.endEdgeSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.endEdgeSize, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_BorderAmounts.EdgeSizes, rhs: CoreML_Specification_BorderAmounts.EdgeSizes) -> Bool {
    if lhs.startEdgeSize != rhs.startEdgeSize {return false}
    if lhs.endEdgeSize != rhs.endEdgeSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ValidPadding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ValidPadding"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paddingAmounts"),
  ]

  fileprivate class _StorageClass {
    var _paddingAmounts: CoreML_Specification_BorderAmounts? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _paddingAmounts = source._paddingAmounts
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._paddingAmounts)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._paddingAmounts {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_ValidPadding, rhs: CoreML_Specification_ValidPadding) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._paddingAmounts != rhs_storage._paddingAmounts {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_SamePadding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SamePadding"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "asymmetryMode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.asymmetryMode)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.asymmetryMode != .bottomRightHeavy {
      try visitor.visitSingularEnumField(value: self.asymmetryMode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_SamePadding, rhs: CoreML_Specification_SamePadding) -> Bool {
    if lhs.asymmetryMode != rhs.asymmetryMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_SamePadding.SamePaddingMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BOTTOM_RIGHT_HEAVY"),
    1: .same(proto: "TOP_LEFT_HEAVY"),
  ]
}

extension CoreML_Specification_SamplingMode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SamplingMode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "samplingMethod"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.samplingMethod)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.samplingMethod != .strictAlignEndpointsMode {
      try visitor.visitSingularEnumField(value: self.samplingMethod, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_SamplingMode, rhs: CoreML_Specification_SamplingMode) -> Bool {
    if lhs.samplingMethod != rhs.samplingMethod {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_SamplingMode.Method: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STRICT_ALIGN_ENDPOINTS_MODE"),
    1: .same(proto: "ALIGN_ENDPOINTS_MODE"),
    2: .same(proto: "UPSAMPLE_MODE"),
    3: .same(proto: "ROI_ALIGN_MODE"),
  ]
}

extension CoreML_Specification_BoxCoordinatesMode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BoxCoordinatesMode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "boxMode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.boxMode)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.boxMode != .cornersHeightFirst {
      try visitor.visitSingularEnumField(value: self.boxMode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_BoxCoordinatesMode, rhs: CoreML_Specification_BoxCoordinatesMode) -> Bool {
    if lhs.boxMode != rhs.boxMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_BoxCoordinatesMode.Coordinates: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CORNERS_HEIGHT_FIRST"),
    1: .same(proto: "CORNERS_WIDTH_FIRST"),
    2: .same(proto: "CENTER_SIZE_HEIGHT_FIRST"),
    3: .same(proto: "CENTER_SIZE_WIDTH_FIRST"),
  ]
}

extension CoreML_Specification_WeightParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WeightParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "floatValue"),
    2: .same(proto: "float16Value"),
    30: .same(proto: "rawValue"),
    40: .same(proto: "quantization"),
  ]

  fileprivate class _StorageClass {
    var _floatValue: [Float] = []
    var _float16Value: Data = SwiftProtobuf.Internal.emptyData
    var _rawValue: Data = SwiftProtobuf.Internal.emptyData
    var _quantization: CoreML_Specification_QuantizationParams? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _floatValue = source._floatValue
      _float16Value = source._float16Value
      _rawValue = source._rawValue
      _quantization = source._quantization
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedFloatField(value: &_storage._floatValue)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._float16Value)
        case 30: try decoder.decodeSingularBytesField(value: &_storage._rawValue)
        case 40: try decoder.decodeSingularMessageField(value: &_storage._quantization)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._floatValue.isEmpty {
        try visitor.visitPackedFloatField(value: _storage._floatValue, fieldNumber: 1)
      }
      if !_storage._float16Value.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._float16Value, fieldNumber: 2)
      }
      if !_storage._rawValue.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._rawValue, fieldNumber: 30)
      }
      if let v = _storage._quantization {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_WeightParams, rhs: CoreML_Specification_WeightParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._floatValue != rhs_storage._floatValue {return false}
        if _storage._float16Value != rhs_storage._float16Value {return false}
        if _storage._rawValue != rhs_storage._rawValue {return false}
        if _storage._quantization != rhs_storage._quantization {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_QuantizationParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuantizationParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "numberOfBits"),
    101: .same(proto: "linearQuantization"),
    102: .same(proto: "lookupTableQuantization"),
  ]

  fileprivate class _StorageClass {
    var _numberOfBits: UInt64 = 0
    var _quantizationType: CoreML_Specification_QuantizationParams.OneOf_QuantizationType?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _numberOfBits = source._numberOfBits
      _quantizationType = source._quantizationType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._numberOfBits)
        case 101:
          var v: CoreML_Specification_LinearQuantizationParams?
          if let current = _storage._quantizationType {
            try decoder.handleConflictingOneOf()
            if case .linearQuantization(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._quantizationType = .linearQuantization(v)}
        case 102:
          var v: CoreML_Specification_LookUpTableQuantizationParams?
          if let current = _storage._quantizationType {
            try decoder.handleConflictingOneOf()
            if case .lookupTableQuantization(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._quantizationType = .lookupTableQuantization(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._numberOfBits != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._numberOfBits, fieldNumber: 1)
      }
      switch _storage._quantizationType {
      case .linearQuantization(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
      case .lookupTableQuantization(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_QuantizationParams, rhs: CoreML_Specification_QuantizationParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._numberOfBits != rhs_storage._numberOfBits {return false}
        if _storage._quantizationType != rhs_storage._quantizationType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_LinearQuantizationParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LinearQuantizationParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scale"),
    2: .same(proto: "bias"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedFloatField(value: &self.scale)
      case 2: try decoder.decodeRepeatedFloatField(value: &self.bias)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scale.isEmpty {
      try visitor.visitPackedFloatField(value: self.scale, fieldNumber: 1)
    }
    if !self.bias.isEmpty {
      try visitor.visitPackedFloatField(value: self.bias, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_LinearQuantizationParams, rhs: CoreML_Specification_LinearQuantizationParams) -> Bool {
    if lhs.scale != rhs.scale {return false}
    if lhs.bias != rhs.bias {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_LookUpTableQuantizationParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LookUpTableQuantizationParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "floatValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedFloatField(value: &self.floatValue)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.floatValue.isEmpty {
      try visitor.visitPackedFloatField(value: self.floatValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_LookUpTableQuantizationParams, rhs: CoreML_Specification_LookUpTableQuantizationParams) -> Bool {
    if lhs.floatValue != rhs.floatValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ConvolutionLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConvolutionLayerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "outputChannels"),
    2: .same(proto: "kernelChannels"),
    10: .same(proto: "nGroups"),
    20: .same(proto: "kernelSize"),
    30: .same(proto: "stride"),
    40: .same(proto: "dilationFactor"),
    50: .same(proto: "valid"),
    51: .same(proto: "same"),
    60: .same(proto: "isDeconvolution"),
    70: .same(proto: "hasBias"),
    90: .same(proto: "weights"),
    91: .same(proto: "bias"),
    100: .same(proto: "outputShape"),
  ]

  fileprivate class _StorageClass {
    var _outputChannels: UInt64 = 0
    var _kernelChannels: UInt64 = 0
    var _nGroups: UInt64 = 0
    var _kernelSize: [UInt64] = []
    var _stride: [UInt64] = []
    var _dilationFactor: [UInt64] = []
    var _convolutionPaddingType: CoreML_Specification_ConvolutionLayerParams.OneOf_ConvolutionPaddingType?
    var _isDeconvolution: Bool = false
    var _hasBias_p: Bool = false
    var _weights: CoreML_Specification_WeightParams? = nil
    var _bias: CoreML_Specification_WeightParams? = nil
    var _outputShape: [UInt64] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _outputChannels = source._outputChannels
      _kernelChannels = source._kernelChannels
      _nGroups = source._nGroups
      _kernelSize = source._kernelSize
      _stride = source._stride
      _dilationFactor = source._dilationFactor
      _convolutionPaddingType = source._convolutionPaddingType
      _isDeconvolution = source._isDeconvolution
      _hasBias_p = source._hasBias_p
      _weights = source._weights
      _bias = source._bias
      _outputShape = source._outputShape
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._outputChannels)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._kernelChannels)
        case 10: try decoder.decodeSingularUInt64Field(value: &_storage._nGroups)
        case 20: try decoder.decodeRepeatedUInt64Field(value: &_storage._kernelSize)
        case 30: try decoder.decodeRepeatedUInt64Field(value: &_storage._stride)
        case 40: try decoder.decodeRepeatedUInt64Field(value: &_storage._dilationFactor)
        case 50:
          var v: CoreML_Specification_ValidPadding?
          if let current = _storage._convolutionPaddingType {
            try decoder.handleConflictingOneOf()
            if case .valid(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._convolutionPaddingType = .valid(v)}
        case 51:
          var v: CoreML_Specification_SamePadding?
          if let current = _storage._convolutionPaddingType {
            try decoder.handleConflictingOneOf()
            if case .same(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._convolutionPaddingType = .same(v)}
        case 60: try decoder.decodeSingularBoolField(value: &_storage._isDeconvolution)
        case 70: try decoder.decodeSingularBoolField(value: &_storage._hasBias_p)
        case 90: try decoder.decodeSingularMessageField(value: &_storage._weights)
        case 91: try decoder.decodeSingularMessageField(value: &_storage._bias)
        case 100: try decoder.decodeRepeatedUInt64Field(value: &_storage._outputShape)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._outputChannels != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._outputChannels, fieldNumber: 1)
      }
      if _storage._kernelChannels != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._kernelChannels, fieldNumber: 2)
      }
      if _storage._nGroups != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._nGroups, fieldNumber: 10)
      }
      if !_storage._kernelSize.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._kernelSize, fieldNumber: 20)
      }
      if !_storage._stride.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._stride, fieldNumber: 30)
      }
      if !_storage._dilationFactor.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._dilationFactor, fieldNumber: 40)
      }
      switch _storage._convolutionPaddingType {
      case .valid(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      case .same(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
      case nil: break
      }
      if _storage._isDeconvolution != false {
        try visitor.visitSingularBoolField(value: _storage._isDeconvolution, fieldNumber: 60)
      }
      if _storage._hasBias_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasBias_p, fieldNumber: 70)
      }
      if let v = _storage._weights {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 90)
      }
      if let v = _storage._bias {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 91)
      }
      if !_storage._outputShape.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._outputShape, fieldNumber: 100)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_ConvolutionLayerParams, rhs: CoreML_Specification_ConvolutionLayerParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._outputChannels != rhs_storage._outputChannels {return false}
        if _storage._kernelChannels != rhs_storage._kernelChannels {return false}
        if _storage._nGroups != rhs_storage._nGroups {return false}
        if _storage._kernelSize != rhs_storage._kernelSize {return false}
        if _storage._stride != rhs_storage._stride {return false}
        if _storage._dilationFactor != rhs_storage._dilationFactor {return false}
        if _storage._convolutionPaddingType != rhs_storage._convolutionPaddingType {return false}
        if _storage._isDeconvolution != rhs_storage._isDeconvolution {return false}
        if _storage._hasBias_p != rhs_storage._hasBias_p {return false}
        if _storage._weights != rhs_storage._weights {return false}
        if _storage._bias != rhs_storage._bias {return false}
        if _storage._outputShape != rhs_storage._outputShape {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_InnerProductLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InnerProductLayerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputChannels"),
    2: .same(proto: "outputChannels"),
    10: .same(proto: "hasBias"),
    20: .same(proto: "weights"),
    21: .same(proto: "bias"),
  ]

  fileprivate class _StorageClass {
    var _inputChannels: UInt64 = 0
    var _outputChannels: UInt64 = 0
    var _hasBias_p: Bool = false
    var _weights: CoreML_Specification_WeightParams? = nil
    var _bias: CoreML_Specification_WeightParams? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _inputChannels = source._inputChannels
      _outputChannels = source._outputChannels
      _hasBias_p = source._hasBias_p
      _weights = source._weights
      _bias = source._bias
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._inputChannels)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._outputChannels)
        case 10: try decoder.decodeSingularBoolField(value: &_storage._hasBias_p)
        case 20: try decoder.decodeSingularMessageField(value: &_storage._weights)
        case 21: try decoder.decodeSingularMessageField(value: &_storage._bias)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._inputChannels != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._inputChannels, fieldNumber: 1)
      }
      if _storage._outputChannels != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._outputChannels, fieldNumber: 2)
      }
      if _storage._hasBias_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasBias_p, fieldNumber: 10)
      }
      if let v = _storage._weights {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
      if let v = _storage._bias {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_InnerProductLayerParams, rhs: CoreML_Specification_InnerProductLayerParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._inputChannels != rhs_storage._inputChannels {return false}
        if _storage._outputChannels != rhs_storage._outputChannels {return false}
        if _storage._hasBias_p != rhs_storage._hasBias_p {return false}
        if _storage._weights != rhs_storage._weights {return false}
        if _storage._bias != rhs_storage._bias {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_EmbeddingLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EmbeddingLayerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputDim"),
    2: .same(proto: "outputChannels"),
    10: .same(proto: "hasBias"),
    20: .same(proto: "weights"),
    21: .same(proto: "bias"),
  ]

  fileprivate class _StorageClass {
    var _inputDim: UInt64 = 0
    var _outputChannels: UInt64 = 0
    var _hasBias_p: Bool = false
    var _weights: CoreML_Specification_WeightParams? = nil
    var _bias: CoreML_Specification_WeightParams? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _inputDim = source._inputDim
      _outputChannels = source._outputChannels
      _hasBias_p = source._hasBias_p
      _weights = source._weights
      _bias = source._bias
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._inputDim)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._outputChannels)
        case 10: try decoder.decodeSingularBoolField(value: &_storage._hasBias_p)
        case 20: try decoder.decodeSingularMessageField(value: &_storage._weights)
        case 21: try decoder.decodeSingularMessageField(value: &_storage._bias)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._inputDim != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._inputDim, fieldNumber: 1)
      }
      if _storage._outputChannels != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._outputChannels, fieldNumber: 2)
      }
      if _storage._hasBias_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasBias_p, fieldNumber: 10)
      }
      if let v = _storage._weights {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
      if let v = _storage._bias {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_EmbeddingLayerParams, rhs: CoreML_Specification_EmbeddingLayerParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._inputDim != rhs_storage._inputDim {return false}
        if _storage._outputChannels != rhs_storage._outputChannels {return false}
        if _storage._hasBias_p != rhs_storage._hasBias_p {return false}
        if _storage._weights != rhs_storage._weights {return false}
        if _storage._bias != rhs_storage._bias {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_BatchnormLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchnormLayerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channels"),
    5: .same(proto: "computeMeanVar"),
    6: .same(proto: "instanceNormalization"),
    10: .same(proto: "epsilon"),
    15: .same(proto: "gamma"),
    16: .same(proto: "beta"),
    17: .same(proto: "mean"),
    18: .same(proto: "variance"),
  ]

  fileprivate class _StorageClass {
    var _channels: UInt64 = 0
    var _computeMeanVar: Bool = false
    var _instanceNormalization: Bool = false
    var _epsilon: Float = 0
    var _gamma: CoreML_Specification_WeightParams? = nil
    var _beta: CoreML_Specification_WeightParams? = nil
    var _mean: CoreML_Specification_WeightParams? = nil
    var _variance: CoreML_Specification_WeightParams? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _channels = source._channels
      _computeMeanVar = source._computeMeanVar
      _instanceNormalization = source._instanceNormalization
      _epsilon = source._epsilon
      _gamma = source._gamma
      _beta = source._beta
      _mean = source._mean
      _variance = source._variance
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._channels)
        case 5: try decoder.decodeSingularBoolField(value: &_storage._computeMeanVar)
        case 6: try decoder.decodeSingularBoolField(value: &_storage._instanceNormalization)
        case 10: try decoder.decodeSingularFloatField(value: &_storage._epsilon)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._gamma)
        case 16: try decoder.decodeSingularMessageField(value: &_storage._beta)
        case 17: try decoder.decodeSingularMessageField(value: &_storage._mean)
        case 18: try decoder.decodeSingularMessageField(value: &_storage._variance)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._channels != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._channels, fieldNumber: 1)
      }
      if _storage._computeMeanVar != false {
        try visitor.visitSingularBoolField(value: _storage._computeMeanVar, fieldNumber: 5)
      }
      if _storage._instanceNormalization != false {
        try visitor.visitSingularBoolField(value: _storage._instanceNormalization, fieldNumber: 6)
      }
      if _storage._epsilon != 0 {
        try visitor.visitSingularFloatField(value: _storage._epsilon, fieldNumber: 10)
      }
      if let v = _storage._gamma {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if let v = _storage._beta {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if let v = _storage._mean {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if let v = _storage._variance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_BatchnormLayerParams, rhs: CoreML_Specification_BatchnormLayerParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._channels != rhs_storage._channels {return false}
        if _storage._computeMeanVar != rhs_storage._computeMeanVar {return false}
        if _storage._instanceNormalization != rhs_storage._instanceNormalization {return false}
        if _storage._epsilon != rhs_storage._epsilon {return false}
        if _storage._gamma != rhs_storage._gamma {return false}
        if _storage._beta != rhs_storage._beta {return false}
        if _storage._mean != rhs_storage._mean {return false}
        if _storage._variance != rhs_storage._variance {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_PoolingLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PoolingLayerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    10: .same(proto: "kernelSize"),
    20: .same(proto: "stride"),
    30: .same(proto: "valid"),
    31: .same(proto: "same"),
    32: .same(proto: "includeLastPixel"),
    50: .same(proto: "avgPoolExcludePadding"),
    60: .same(proto: "globalPooling"),
  ]

  fileprivate class _StorageClass {
    var _type: CoreML_Specification_PoolingLayerParams.PoolingType = .max
    var _kernelSize: [UInt64] = []
    var _stride: [UInt64] = []
    var _poolingPaddingType: CoreML_Specification_PoolingLayerParams.OneOf_PoolingPaddingType?
    var _avgPoolExcludePadding: Bool = false
    var _globalPooling: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _kernelSize = source._kernelSize
      _stride = source._stride
      _poolingPaddingType = source._poolingPaddingType
      _avgPoolExcludePadding = source._avgPoolExcludePadding
      _globalPooling = source._globalPooling
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 10: try decoder.decodeRepeatedUInt64Field(value: &_storage._kernelSize)
        case 20: try decoder.decodeRepeatedUInt64Field(value: &_storage._stride)
        case 30:
          var v: CoreML_Specification_ValidPadding?
          if let current = _storage._poolingPaddingType {
            try decoder.handleConflictingOneOf()
            if case .valid(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._poolingPaddingType = .valid(v)}
        case 31:
          var v: CoreML_Specification_SamePadding?
          if let current = _storage._poolingPaddingType {
            try decoder.handleConflictingOneOf()
            if case .same(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._poolingPaddingType = .same(v)}
        case 32:
          var v: CoreML_Specification_PoolingLayerParams.ValidCompletePadding?
          if let current = _storage._poolingPaddingType {
            try decoder.handleConflictingOneOf()
            if case .includeLastPixel(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._poolingPaddingType = .includeLastPixel(v)}
        case 50: try decoder.decodeSingularBoolField(value: &_storage._avgPoolExcludePadding)
        case 60: try decoder.decodeSingularBoolField(value: &_storage._globalPooling)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._type != .max {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 1)
      }
      if !_storage._kernelSize.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._kernelSize, fieldNumber: 10)
      }
      if !_storage._stride.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._stride, fieldNumber: 20)
      }
      switch _storage._poolingPaddingType {
      case .valid(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      case .same(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      case .includeLastPixel(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      case nil: break
      }
      if _storage._avgPoolExcludePadding != false {
        try visitor.visitSingularBoolField(value: _storage._avgPoolExcludePadding, fieldNumber: 50)
      }
      if _storage._globalPooling != false {
        try visitor.visitSingularBoolField(value: _storage._globalPooling, fieldNumber: 60)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_PoolingLayerParams, rhs: CoreML_Specification_PoolingLayerParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._kernelSize != rhs_storage._kernelSize {return false}
        if _storage._stride != rhs_storage._stride {return false}
        if _storage._poolingPaddingType != rhs_storage._poolingPaddingType {return false}
        if _storage._avgPoolExcludePadding != rhs_storage._avgPoolExcludePadding {return false}
        if _storage._globalPooling != rhs_storage._globalPooling {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_PoolingLayerParams.PoolingType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MAX"),
    1: .same(proto: "AVERAGE"),
    2: .same(proto: "L2"),
  ]
}

extension CoreML_Specification_PoolingLayerParams.ValidCompletePadding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CoreML_Specification_PoolingLayerParams.protoMessageName + ".ValidCompletePadding"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    10: .same(proto: "paddingAmounts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 10: try decoder.decodeRepeatedUInt64Field(value: &self.paddingAmounts)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.paddingAmounts.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.paddingAmounts, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_PoolingLayerParams.ValidCompletePadding, rhs: CoreML_Specification_PoolingLayerParams.ValidCompletePadding) -> Bool {
    if lhs.paddingAmounts != rhs.paddingAmounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_PaddingLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PaddingLayerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "constant"),
    2: .same(proto: "reflection"),
    3: .same(proto: "replication"),
    10: .same(proto: "paddingAmounts"),
  ]

  fileprivate class _StorageClass {
    var _paddingType: CoreML_Specification_PaddingLayerParams.OneOf_PaddingType?
    var _paddingAmounts: CoreML_Specification_BorderAmounts? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _paddingType = source._paddingType
      _paddingAmounts = source._paddingAmounts
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: CoreML_Specification_PaddingLayerParams.PaddingConstant?
          if let current = _storage._paddingType {
            try decoder.handleConflictingOneOf()
            if case .constant(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._paddingType = .constant(v)}
        case 2:
          var v: CoreML_Specification_PaddingLayerParams.PaddingReflection?
          if let current = _storage._paddingType {
            try decoder.handleConflictingOneOf()
            if case .reflection(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._paddingType = .reflection(v)}
        case 3:
          var v: CoreML_Specification_PaddingLayerParams.PaddingReplication?
          if let current = _storage._paddingType {
            try decoder.handleConflictingOneOf()
            if case .replication(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._paddingType = .replication(v)}
        case 10: try decoder.decodeSingularMessageField(value: &_storage._paddingAmounts)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._paddingType {
      case .constant(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .reflection(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .replication(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
      if let v = _storage._paddingAmounts {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_PaddingLayerParams, rhs: CoreML_Specification_PaddingLayerParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._paddingType != rhs_storage._paddingType {return false}
        if _storage._paddingAmounts != rhs_storage._paddingAmounts {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_PaddingLayerParams.PaddingConstant: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CoreML_Specification_PaddingLayerParams.protoMessageName + ".PaddingConstant"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.value)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularFloatField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_PaddingLayerParams.PaddingConstant, rhs: CoreML_Specification_PaddingLayerParams.PaddingConstant) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_PaddingLayerParams.PaddingReflection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CoreML_Specification_PaddingLayerParams.protoMessageName + ".PaddingReflection"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_PaddingLayerParams.PaddingReflection, rhs: CoreML_Specification_PaddingLayerParams.PaddingReflection) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_PaddingLayerParams.PaddingReplication: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CoreML_Specification_PaddingLayerParams.protoMessageName + ".PaddingReplication"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_PaddingLayerParams.PaddingReplication, rhs: CoreML_Specification_PaddingLayerParams.PaddingReplication) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ConcatLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConcatLayerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    100: .same(proto: "sequenceConcat"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 100: try decoder.decodeSingularBoolField(value: &self.sequenceConcat)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sequenceConcat != false {
      try visitor.visitSingularBoolField(value: self.sequenceConcat, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_ConcatLayerParams, rhs: CoreML_Specification_ConcatLayerParams) -> Bool {
    if lhs.sequenceConcat != rhs.sequenceConcat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_LRNLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LRNLayerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
    2: .same(proto: "beta"),
    3: .same(proto: "localSize"),
    4: .same(proto: "k"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.alpha)
      case 2: try decoder.decodeSingularFloatField(value: &self.beta)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.localSize)
      case 4: try decoder.decodeSingularFloatField(value: &self.k)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 1)
    }
    if self.beta != 0 {
      try visitor.visitSingularFloatField(value: self.beta, fieldNumber: 2)
    }
    if self.localSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.localSize, fieldNumber: 3)
    }
    if self.k != 0 {
      try visitor.visitSingularFloatField(value: self.k, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_LRNLayerParams, rhs: CoreML_Specification_LRNLayerParams) -> Bool {
    if lhs.alpha != rhs.alpha {return false}
    if lhs.beta != rhs.beta {return false}
    if lhs.localSize != rhs.localSize {return false}
    if lhs.k != rhs.k {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_SoftmaxLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SoftmaxLayerParams"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_SoftmaxLayerParams, rhs: CoreML_Specification_SoftmaxLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_SplitLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SplitLayerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nOutputs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.nOutputs)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nOutputs != 0 {
      try visitor.visitSingularUInt64Field(value: self.nOutputs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_SplitLayerParams, rhs: CoreML_Specification_SplitLayerParams) -> Bool {
    if lhs.nOutputs != rhs.nOutputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_AddLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddLayerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.alpha)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_AddLayerParams, rhs: CoreML_Specification_AddLayerParams) -> Bool {
    if lhs.alpha != rhs.alpha {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_MultiplyLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MultiplyLayerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.alpha)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_MultiplyLayerParams, rhs: CoreML_Specification_MultiplyLayerParams) -> Bool {
    if lhs.alpha != rhs.alpha {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_UnaryFunctionLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnaryFunctionLayerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "alpha"),
    3: .same(proto: "epsilon"),
    4: .same(proto: "shift"),
    5: .same(proto: "scale"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularFloatField(value: &self.alpha)
      case 3: try decoder.decodeSingularFloatField(value: &self.epsilon)
      case 4: try decoder.decodeSingularFloatField(value: &self.shift)
      case 5: try decoder.decodeSingularFloatField(value: &self.scale)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .sqrt {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 2)
    }
    if self.epsilon != 0 {
      try visitor.visitSingularFloatField(value: self.epsilon, fieldNumber: 3)
    }
    if self.shift != 0 {
      try visitor.visitSingularFloatField(value: self.shift, fieldNumber: 4)
    }
    if self.scale != 0 {
      try visitor.visitSingularFloatField(value: self.scale, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_UnaryFunctionLayerParams, rhs: CoreML_Specification_UnaryFunctionLayerParams) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.alpha != rhs.alpha {return false}
    if lhs.epsilon != rhs.epsilon {return false}
    if lhs.shift != rhs.shift {return false}
    if lhs.scale != rhs.scale {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_UnaryFunctionLayerParams.Operation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SQRT"),
    1: .same(proto: "RSQRT"),
    2: .same(proto: "INVERSE"),
    3: .same(proto: "POWER"),
    4: .same(proto: "EXP"),
    5: .same(proto: "LOG"),
    6: .same(proto: "ABS"),
    7: .same(proto: "THRESHOLD"),
  ]
}

extension CoreML_Specification_UpsampleLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpsampleLayerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scalingFactor"),
    5: .same(proto: "mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedUInt64Field(value: &self.scalingFactor)
      case 5: try decoder.decodeSingularEnumField(value: &self.mode)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scalingFactor.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.scalingFactor, fieldNumber: 1)
    }
    if self.mode != .nn {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_UpsampleLayerParams, rhs: CoreML_Specification_UpsampleLayerParams) -> Bool {
    if lhs.scalingFactor != rhs.scalingFactor {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_UpsampleLayerParams.InterpolationMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NN"),
    1: .same(proto: "BILINEAR"),
  ]
}

extension CoreML_Specification_ResizeBilinearLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResizeBilinearLayerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targetSize"),
    2: .same(proto: "mode"),
  ]

  fileprivate class _StorageClass {
    var _targetSize: [UInt64] = []
    var _mode: CoreML_Specification_SamplingMode? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _targetSize = source._targetSize
      _mode = source._mode
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedUInt64Field(value: &_storage._targetSize)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._mode)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._targetSize.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._targetSize, fieldNumber: 1)
      }
      if let v = _storage._mode {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_ResizeBilinearLayerParams, rhs: CoreML_Specification_ResizeBilinearLayerParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._targetSize != rhs_storage._targetSize {return false}
        if _storage._mode != rhs_storage._mode {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_CropResizeLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CropResizeLayerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targetSize"),
    2: .same(proto: "normalizedCoordinates"),
    3: .same(proto: "mode"),
    4: .same(proto: "boxIndicesMode"),
    5: .same(proto: "spatialScale"),
  ]

  fileprivate class _StorageClass {
    var _targetSize: [UInt64] = []
    var _normalizedCoordinates: Bool = false
    var _mode: CoreML_Specification_SamplingMode? = nil
    var _boxIndicesMode: CoreML_Specification_BoxCoordinatesMode? = nil
    var _spatialScale: Float = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _targetSize = source._targetSize
      _normalizedCoordinates = source._normalizedCoordinates
      _mode = source._mode
      _boxIndicesMode = source._boxIndicesMode
      _spatialScale = source._spatialScale
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedUInt64Field(value: &_storage._targetSize)
        case 2: try decoder.decodeSingularBoolField(value: &_storage._normalizedCoordinates)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._mode)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._boxIndicesMode)
        case 5: try decoder.decodeSingularFloatField(value: &_storage._spatialScale)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._targetSize.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._targetSize, fieldNumber: 1)
      }
      if _storage._normalizedCoordinates != false {
        try visitor.visitSingularBoolField(value: _storage._normalizedCoordinates, fieldNumber: 2)
      }
      if let v = _storage._mode {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._boxIndicesMode {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if _storage._spatialScale != 0 {
        try visitor.visitSingularFloatField(value: _storage._spatialScale, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_CropResizeLayerParams, rhs: CoreML_Specification_CropResizeLayerParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._targetSize != rhs_storage._targetSize {return false}
        if _storage._normalizedCoordinates != rhs_storage._normalizedCoordinates {return false}
        if _storage._mode != rhs_storage._mode {return false}
        if _storage._boxIndicesMode != rhs_storage._boxIndicesMode {return false}
        if _storage._spatialScale != rhs_storage._spatialScale {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_BiasLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BiasLayerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shape"),
    2: .same(proto: "bias"),
  ]

  fileprivate class _StorageClass {
    var _shape: [UInt64] = []
    var _bias: CoreML_Specification_WeightParams? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _shape = source._shape
      _bias = source._bias
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedUInt64Field(value: &_storage._shape)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._bias)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._shape.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._shape, fieldNumber: 1)
      }
      if let v = _storage._bias {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_BiasLayerParams, rhs: CoreML_Specification_BiasLayerParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._shape != rhs_storage._shape {return false}
        if _storage._bias != rhs_storage._bias {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ScaleLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScaleLayerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shapeScale"),
    2: .same(proto: "scale"),
    3: .same(proto: "hasBias"),
    4: .same(proto: "shapeBias"),
    5: .same(proto: "bias"),
  ]

  fileprivate class _StorageClass {
    var _shapeScale: [UInt64] = []
    var _scale: CoreML_Specification_WeightParams? = nil
    var _hasBias_p: Bool = false
    var _shapeBias: [UInt64] = []
    var _bias: CoreML_Specification_WeightParams? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _shapeScale = source._shapeScale
      _scale = source._scale
      _hasBias_p = source._hasBias_p
      _shapeBias = source._shapeBias
      _bias = source._bias
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedUInt64Field(value: &_storage._shapeScale)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._scale)
        case 3: try decoder.decodeSingularBoolField(value: &_storage._hasBias_p)
        case 4: try decoder.decodeRepeatedUInt64Field(value: &_storage._shapeBias)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._bias)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._shapeScale.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._shapeScale, fieldNumber: 1)
      }
      if let v = _storage._scale {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._hasBias_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasBias_p, fieldNumber: 3)
      }
      if !_storage._shapeBias.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._shapeBias, fieldNumber: 4)
      }
      if let v = _storage._bias {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_ScaleLayerParams, rhs: CoreML_Specification_ScaleLayerParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._shapeScale != rhs_storage._shapeScale {return false}
        if _storage._scale != rhs_storage._scale {return false}
        if _storage._hasBias_p != rhs_storage._hasBias_p {return false}
        if _storage._shapeBias != rhs_storage._shapeBias {return false}
        if _storage._bias != rhs_storage._bias {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_LoadConstantLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LoadConstantLayerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shape"),
    2: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _shape: [UInt64] = []
    var _data: CoreML_Specification_WeightParams? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _shape = source._shape
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedUInt64Field(value: &_storage._shape)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._shape.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._shape, fieldNumber: 1)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_LoadConstantLayerParams, rhs: CoreML_Specification_LoadConstantLayerParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._shape != rhs_storage._shape {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_L2NormalizeLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".L2NormalizeLayerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "epsilon"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.epsilon)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.epsilon != 0 {
      try visitor.visitSingularFloatField(value: self.epsilon, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_L2NormalizeLayerParams, rhs: CoreML_Specification_L2NormalizeLayerParams) -> Bool {
    if lhs.epsilon != rhs.epsilon {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_FlattenLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FlattenLayerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.mode)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mode != .channelFirst {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_FlattenLayerParams, rhs: CoreML_Specification_FlattenLayerParams) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_FlattenLayerParams.FlattenOrder: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHANNEL_FIRST"),
    1: .same(proto: "CHANNEL_LAST"),
  ]
}

extension CoreML_Specification_ReshapeLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReshapeLayerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targetShape"),
    2: .same(proto: "mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedInt64Field(value: &self.targetShape)
      case 2: try decoder.decodeSingularEnumField(value: &self.mode)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetShape.isEmpty {
      try visitor.visitPackedInt64Field(value: self.targetShape, fieldNumber: 1)
    }
    if self.mode != .channelFirst {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_ReshapeLayerParams, rhs: CoreML_Specification_ReshapeLayerParams) -> Bool {
    if lhs.targetShape != rhs.targetShape {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ReshapeLayerParams.ReshapeOrder: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHANNEL_FIRST"),
    1: .same(proto: "CHANNEL_LAST"),
  ]
}

extension CoreML_Specification_PermuteLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PermuteLayerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "axis"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedUInt64Field(value: &self.axis)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.axis.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.axis, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_PermuteLayerParams, rhs: CoreML_Specification_PermuteLayerParams) -> Bool {
    if lhs.axis != rhs.axis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ReorganizeDataLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReorganizeDataLayerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
    2: .same(proto: "blockSize"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.mode)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.blockSize)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mode != .spaceToDepth {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    if self.blockSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.blockSize, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_ReorganizeDataLayerParams, rhs: CoreML_Specification_ReorganizeDataLayerParams) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.blockSize != rhs.blockSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ReorganizeDataLayerParams.ReorganizationType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SPACE_TO_DEPTH"),
    1: .same(proto: "DEPTH_TO_SPACE"),
  ]
}

extension CoreML_Specification_SliceLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SliceLayerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "startIndex"),
    2: .same(proto: "endIndex"),
    3: .same(proto: "stride"),
    4: .same(proto: "axis"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.startIndex)
      case 2: try decoder.decodeSingularInt64Field(value: &self.endIndex)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.stride)
      case 4: try decoder.decodeSingularEnumField(value: &self.axis)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startIndex != 0 {
      try visitor.visitSingularInt64Field(value: self.startIndex, fieldNumber: 1)
    }
    if self.endIndex != 0 {
      try visitor.visitSingularInt64Field(value: self.endIndex, fieldNumber: 2)
    }
    if self.stride != 0 {
      try visitor.visitSingularUInt64Field(value: self.stride, fieldNumber: 3)
    }
    if self.axis != .channelAxis {
      try visitor.visitSingularEnumField(value: self.axis, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_SliceLayerParams, rhs: CoreML_Specification_SliceLayerParams) -> Bool {
    if lhs.startIndex != rhs.startIndex {return false}
    if lhs.endIndex != rhs.endIndex {return false}
    if lhs.stride != rhs.stride {return false}
    if lhs.axis != rhs.axis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_SliceLayerParams.SliceAxis: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHANNEL_AXIS"),
    1: .same(proto: "HEIGHT_AXIS"),
    2: .same(proto: "WIDTH_AXIS"),
  ]
}

extension CoreML_Specification_ReduceLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReduceLayerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
    2: .same(proto: "epsilon"),
    3: .same(proto: "axis"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.mode)
      case 2: try decoder.decodeSingularFloatField(value: &self.epsilon)
      case 3: try decoder.decodeSingularEnumField(value: &self.axis)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mode != .sum {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    if self.epsilon != 0 {
      try visitor.visitSingularFloatField(value: self.epsilon, fieldNumber: 2)
    }
    if self.axis != .chw {
      try visitor.visitSingularEnumField(value: self.axis, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_ReduceLayerParams, rhs: CoreML_Specification_ReduceLayerParams) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.epsilon != rhs.epsilon {return false}
    if lhs.axis != rhs.axis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ReduceLayerParams.ReduceOperation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUM"),
    1: .same(proto: "AVG"),
    2: .same(proto: "PROD"),
    3: .same(proto: "LOGSUM"),
    4: .same(proto: "SUMSQUARE"),
    5: .same(proto: "L1"),
    6: .same(proto: "L2"),
    7: .same(proto: "MAX"),
    8: .same(proto: "MIN"),
    9: .same(proto: "ARGMAX"),
  ]
}

extension CoreML_Specification_ReduceLayerParams.ReduceAxis: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHW"),
    1: .same(proto: "HW"),
    2: .same(proto: "C"),
    3: .same(proto: "H"),
    4: .same(proto: "W"),
  ]
}

extension CoreML_Specification_CropLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CropLayerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cropAmounts"),
    5: .same(proto: "offset"),
  ]

  fileprivate class _StorageClass {
    var _cropAmounts: CoreML_Specification_BorderAmounts? = nil
    var _offset: [UInt64] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _cropAmounts = source._cropAmounts
      _offset = source._offset
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._cropAmounts)
        case 5: try decoder.decodeRepeatedUInt64Field(value: &_storage._offset)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._cropAmounts {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._offset.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._offset, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_CropLayerParams, rhs: CoreML_Specification_CropLayerParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._cropAmounts != rhs_storage._cropAmounts {return false}
        if _storage._offset != rhs_storage._offset {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_AverageLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AverageLayerParams"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_AverageLayerParams, rhs: CoreML_Specification_AverageLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_MaxLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MaxLayerParams"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_MaxLayerParams, rhs: CoreML_Specification_MaxLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_MinLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MinLayerParams"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_MinLayerParams, rhs: CoreML_Specification_MinLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_DotProductLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DotProductLayerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cosineSimilarity"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.cosineSimilarity)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.cosineSimilarity != false {
      try visitor.visitSingularBoolField(value: self.cosineSimilarity, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_DotProductLayerParams, rhs: CoreML_Specification_DotProductLayerParams) -> Bool {
    if lhs.cosineSimilarity != rhs.cosineSimilarity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_MeanVarianceNormalizeLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MeanVarianceNormalizeLayerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "acrossChannels"),
    2: .same(proto: "normalizeVariance"),
    3: .same(proto: "epsilon"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.acrossChannels)
      case 2: try decoder.decodeSingularBoolField(value: &self.normalizeVariance)
      case 3: try decoder.decodeSingularFloatField(value: &self.epsilon)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.acrossChannels != false {
      try visitor.visitSingularBoolField(value: self.acrossChannels, fieldNumber: 1)
    }
    if self.normalizeVariance != false {
      try visitor.visitSingularBoolField(value: self.normalizeVariance, fieldNumber: 2)
    }
    if self.epsilon != 0 {
      try visitor.visitSingularFloatField(value: self.epsilon, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_MeanVarianceNormalizeLayerParams, rhs: CoreML_Specification_MeanVarianceNormalizeLayerParams) -> Bool {
    if lhs.acrossChannels != rhs.acrossChannels {return false}
    if lhs.normalizeVariance != rhs.normalizeVariance {return false}
    if lhs.epsilon != rhs.epsilon {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_SequenceRepeatLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SequenceRepeatLayerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nRepetitions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.nRepetitions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nRepetitions != 0 {
      try visitor.visitSingularUInt64Field(value: self.nRepetitions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_SequenceRepeatLayerParams, rhs: CoreML_Specification_SequenceRepeatLayerParams) -> Bool {
    if lhs.nRepetitions != rhs.nRepetitions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_SimpleRecurrentLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SimpleRecurrentLayerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputVectorSize"),
    2: .same(proto: "outputVectorSize"),
    10: .same(proto: "activation"),
    15: .same(proto: "sequenceOutput"),
    20: .same(proto: "hasBiasVector"),
    30: .same(proto: "weightMatrix"),
    31: .same(proto: "recursionMatrix"),
    32: .same(proto: "biasVector"),
    100: .same(proto: "reverseInput"),
  ]

  fileprivate class _StorageClass {
    var _inputVectorSize: UInt64 = 0
    var _outputVectorSize: UInt64 = 0
    var _activation: CoreML_Specification_ActivationParams? = nil
    var _sequenceOutput: Bool = false
    var _hasBiasVector_p: Bool = false
    var _weightMatrix: CoreML_Specification_WeightParams? = nil
    var _recursionMatrix: CoreML_Specification_WeightParams? = nil
    var _biasVector: CoreML_Specification_WeightParams? = nil
    var _reverseInput: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _inputVectorSize = source._inputVectorSize
      _outputVectorSize = source._outputVectorSize
      _activation = source._activation
      _sequenceOutput = source._sequenceOutput
      _hasBiasVector_p = source._hasBiasVector_p
      _weightMatrix = source._weightMatrix
      _recursionMatrix = source._recursionMatrix
      _biasVector = source._biasVector
      _reverseInput = source._reverseInput
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._inputVectorSize)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._outputVectorSize)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._activation)
        case 15: try decoder.decodeSingularBoolField(value: &_storage._sequenceOutput)
        case 20: try decoder.decodeSingularBoolField(value: &_storage._hasBiasVector_p)
        case 30: try decoder.decodeSingularMessageField(value: &_storage._weightMatrix)
        case 31: try decoder.decodeSingularMessageField(value: &_storage._recursionMatrix)
        case 32: try decoder.decodeSingularMessageField(value: &_storage._biasVector)
        case 100: try decoder.decodeSingularBoolField(value: &_storage._reverseInput)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._inputVectorSize != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._inputVectorSize, fieldNumber: 1)
      }
      if _storage._outputVectorSize != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._outputVectorSize, fieldNumber: 2)
      }
      if let v = _storage._activation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if _storage._sequenceOutput != false {
        try visitor.visitSingularBoolField(value: _storage._sequenceOutput, fieldNumber: 15)
      }
      if _storage._hasBiasVector_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasBiasVector_p, fieldNumber: 20)
      }
      if let v = _storage._weightMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      }
      if let v = _storage._recursionMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      }
      if let v = _storage._biasVector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      }
      if _storage._reverseInput != false {
        try visitor.visitSingularBoolField(value: _storage._reverseInput, fieldNumber: 100)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_SimpleRecurrentLayerParams, rhs: CoreML_Specification_SimpleRecurrentLayerParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._inputVectorSize != rhs_storage._inputVectorSize {return false}
        if _storage._outputVectorSize != rhs_storage._outputVectorSize {return false}
        if _storage._activation != rhs_storage._activation {return false}
        if _storage._sequenceOutput != rhs_storage._sequenceOutput {return false}
        if _storage._hasBiasVector_p != rhs_storage._hasBiasVector_p {return false}
        if _storage._weightMatrix != rhs_storage._weightMatrix {return false}
        if _storage._recursionMatrix != rhs_storage._recursionMatrix {return false}
        if _storage._biasVector != rhs_storage._biasVector {return false}
        if _storage._reverseInput != rhs_storage._reverseInput {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_GRULayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GRULayerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputVectorSize"),
    2: .same(proto: "outputVectorSize"),
    10: .same(proto: "activations"),
    15: .same(proto: "sequenceOutput"),
    20: .same(proto: "hasBiasVectors"),
    30: .same(proto: "updateGateWeightMatrix"),
    31: .same(proto: "resetGateWeightMatrix"),
    32: .same(proto: "outputGateWeightMatrix"),
    50: .same(proto: "updateGateRecursionMatrix"),
    51: .same(proto: "resetGateRecursionMatrix"),
    52: .same(proto: "outputGateRecursionMatrix"),
    70: .same(proto: "updateGateBiasVector"),
    71: .same(proto: "resetGateBiasVector"),
    72: .same(proto: "outputGateBiasVector"),
    100: .same(proto: "reverseInput"),
  ]

  fileprivate class _StorageClass {
    var _inputVectorSize: UInt64 = 0
    var _outputVectorSize: UInt64 = 0
    var _activations: [CoreML_Specification_ActivationParams] = []
    var _sequenceOutput: Bool = false
    var _hasBiasVectors_p: Bool = false
    var _updateGateWeightMatrix: CoreML_Specification_WeightParams? = nil
    var _resetGateWeightMatrix: CoreML_Specification_WeightParams? = nil
    var _outputGateWeightMatrix: CoreML_Specification_WeightParams? = nil
    var _updateGateRecursionMatrix: CoreML_Specification_WeightParams? = nil
    var _resetGateRecursionMatrix: CoreML_Specification_WeightParams? = nil
    var _outputGateRecursionMatrix: CoreML_Specification_WeightParams? = nil
    var _updateGateBiasVector: CoreML_Specification_WeightParams? = nil
    var _resetGateBiasVector: CoreML_Specification_WeightParams? = nil
    var _outputGateBiasVector: CoreML_Specification_WeightParams? = nil
    var _reverseInput: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _inputVectorSize = source._inputVectorSize
      _outputVectorSize = source._outputVectorSize
      _activations = source._activations
      _sequenceOutput = source._sequenceOutput
      _hasBiasVectors_p = source._hasBiasVectors_p
      _updateGateWeightMatrix = source._updateGateWeightMatrix
      _resetGateWeightMatrix = source._resetGateWeightMatrix
      _outputGateWeightMatrix = source._outputGateWeightMatrix
      _updateGateRecursionMatrix = source._updateGateRecursionMatrix
      _resetGateRecursionMatrix = source._resetGateRecursionMatrix
      _outputGateRecursionMatrix = source._outputGateRecursionMatrix
      _updateGateBiasVector = source._updateGateBiasVector
      _resetGateBiasVector = source._resetGateBiasVector
      _outputGateBiasVector = source._outputGateBiasVector
      _reverseInput = source._reverseInput
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._inputVectorSize)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._outputVectorSize)
        case 10: try decoder.decodeRepeatedMessageField(value: &_storage._activations)
        case 15: try decoder.decodeSingularBoolField(value: &_storage._sequenceOutput)
        case 20: try decoder.decodeSingularBoolField(value: &_storage._hasBiasVectors_p)
        case 30: try decoder.decodeSingularMessageField(value: &_storage._updateGateWeightMatrix)
        case 31: try decoder.decodeSingularMessageField(value: &_storage._resetGateWeightMatrix)
        case 32: try decoder.decodeSingularMessageField(value: &_storage._outputGateWeightMatrix)
        case 50: try decoder.decodeSingularMessageField(value: &_storage._updateGateRecursionMatrix)
        case 51: try decoder.decodeSingularMessageField(value: &_storage._resetGateRecursionMatrix)
        case 52: try decoder.decodeSingularMessageField(value: &_storage._outputGateRecursionMatrix)
        case 70: try decoder.decodeSingularMessageField(value: &_storage._updateGateBiasVector)
        case 71: try decoder.decodeSingularMessageField(value: &_storage._resetGateBiasVector)
        case 72: try decoder.decodeSingularMessageField(value: &_storage._outputGateBiasVector)
        case 100: try decoder.decodeSingularBoolField(value: &_storage._reverseInput)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._inputVectorSize != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._inputVectorSize, fieldNumber: 1)
      }
      if _storage._outputVectorSize != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._outputVectorSize, fieldNumber: 2)
      }
      if !_storage._activations.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._activations, fieldNumber: 10)
      }
      if _storage._sequenceOutput != false {
        try visitor.visitSingularBoolField(value: _storage._sequenceOutput, fieldNumber: 15)
      }
      if _storage._hasBiasVectors_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasBiasVectors_p, fieldNumber: 20)
      }
      if let v = _storage._updateGateWeightMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      }
      if let v = _storage._resetGateWeightMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      }
      if let v = _storage._outputGateWeightMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      }
      if let v = _storage._updateGateRecursionMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      }
      if let v = _storage._resetGateRecursionMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
      }
      if let v = _storage._outputGateRecursionMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
      }
      if let v = _storage._updateGateBiasVector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 70)
      }
      if let v = _storage._resetGateBiasVector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 71)
      }
      if let v = _storage._outputGateBiasVector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 72)
      }
      if _storage._reverseInput != false {
        try visitor.visitSingularBoolField(value: _storage._reverseInput, fieldNumber: 100)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_GRULayerParams, rhs: CoreML_Specification_GRULayerParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._inputVectorSize != rhs_storage._inputVectorSize {return false}
        if _storage._outputVectorSize != rhs_storage._outputVectorSize {return false}
        if _storage._activations != rhs_storage._activations {return false}
        if _storage._sequenceOutput != rhs_storage._sequenceOutput {return false}
        if _storage._hasBiasVectors_p != rhs_storage._hasBiasVectors_p {return false}
        if _storage._updateGateWeightMatrix != rhs_storage._updateGateWeightMatrix {return false}
        if _storage._resetGateWeightMatrix != rhs_storage._resetGateWeightMatrix {return false}
        if _storage._outputGateWeightMatrix != rhs_storage._outputGateWeightMatrix {return false}
        if _storage._updateGateRecursionMatrix != rhs_storage._updateGateRecursionMatrix {return false}
        if _storage._resetGateRecursionMatrix != rhs_storage._resetGateRecursionMatrix {return false}
        if _storage._outputGateRecursionMatrix != rhs_storage._outputGateRecursionMatrix {return false}
        if _storage._updateGateBiasVector != rhs_storage._updateGateBiasVector {return false}
        if _storage._resetGateBiasVector != rhs_storage._resetGateBiasVector {return false}
        if _storage._outputGateBiasVector != rhs_storage._outputGateBiasVector {return false}
        if _storage._reverseInput != rhs_storage._reverseInput {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_LSTMParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LSTMParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    10: .same(proto: "sequenceOutput"),
    20: .same(proto: "hasBiasVectors"),
    30: .same(proto: "forgetBias"),
    40: .same(proto: "hasPeepholeVectors"),
    50: .same(proto: "coupledInputAndForgetGate"),
    60: .same(proto: "cellClipThreshold"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 10: try decoder.decodeSingularBoolField(value: &self.sequenceOutput)
      case 20: try decoder.decodeSingularBoolField(value: &self.hasBiasVectors_p)
      case 30: try decoder.decodeSingularBoolField(value: &self.forgetBias)
      case 40: try decoder.decodeSingularBoolField(value: &self.hasPeepholeVectors_p)
      case 50: try decoder.decodeSingularBoolField(value: &self.coupledInputAndForgetGate)
      case 60: try decoder.decodeSingularFloatField(value: &self.cellClipThreshold)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sequenceOutput != false {
      try visitor.visitSingularBoolField(value: self.sequenceOutput, fieldNumber: 10)
    }
    if self.hasBiasVectors_p != false {
      try visitor.visitSingularBoolField(value: self.hasBiasVectors_p, fieldNumber: 20)
    }
    if self.forgetBias != false {
      try visitor.visitSingularBoolField(value: self.forgetBias, fieldNumber: 30)
    }
    if self.hasPeepholeVectors_p != false {
      try visitor.visitSingularBoolField(value: self.hasPeepholeVectors_p, fieldNumber: 40)
    }
    if self.coupledInputAndForgetGate != false {
      try visitor.visitSingularBoolField(value: self.coupledInputAndForgetGate, fieldNumber: 50)
    }
    if self.cellClipThreshold != 0 {
      try visitor.visitSingularFloatField(value: self.cellClipThreshold, fieldNumber: 60)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_LSTMParams, rhs: CoreML_Specification_LSTMParams) -> Bool {
    if lhs.sequenceOutput != rhs.sequenceOutput {return false}
    if lhs.hasBiasVectors_p != rhs.hasBiasVectors_p {return false}
    if lhs.forgetBias != rhs.forgetBias {return false}
    if lhs.hasPeepholeVectors_p != rhs.hasPeepholeVectors_p {return false}
    if lhs.coupledInputAndForgetGate != rhs.coupledInputAndForgetGate {return false}
    if lhs.cellClipThreshold != rhs.cellClipThreshold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_LSTMWeightParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LSTMWeightParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputGateWeightMatrix"),
    2: .same(proto: "forgetGateWeightMatrix"),
    3: .same(proto: "blockInputWeightMatrix"),
    4: .same(proto: "outputGateWeightMatrix"),
    20: .same(proto: "inputGateRecursionMatrix"),
    21: .same(proto: "forgetGateRecursionMatrix"),
    22: .same(proto: "blockInputRecursionMatrix"),
    23: .same(proto: "outputGateRecursionMatrix"),
    40: .same(proto: "inputGateBiasVector"),
    41: .same(proto: "forgetGateBiasVector"),
    42: .same(proto: "blockInputBiasVector"),
    43: .same(proto: "outputGateBiasVector"),
    60: .same(proto: "inputGatePeepholeVector"),
    61: .same(proto: "forgetGatePeepholeVector"),
    62: .same(proto: "outputGatePeepholeVector"),
  ]

  fileprivate class _StorageClass {
    var _inputGateWeightMatrix: CoreML_Specification_WeightParams? = nil
    var _forgetGateWeightMatrix: CoreML_Specification_WeightParams? = nil
    var _blockInputWeightMatrix: CoreML_Specification_WeightParams? = nil
    var _outputGateWeightMatrix: CoreML_Specification_WeightParams? = nil
    var _inputGateRecursionMatrix: CoreML_Specification_WeightParams? = nil
    var _forgetGateRecursionMatrix: CoreML_Specification_WeightParams? = nil
    var _blockInputRecursionMatrix: CoreML_Specification_WeightParams? = nil
    var _outputGateRecursionMatrix: CoreML_Specification_WeightParams? = nil
    var _inputGateBiasVector: CoreML_Specification_WeightParams? = nil
    var _forgetGateBiasVector: CoreML_Specification_WeightParams? = nil
    var _blockInputBiasVector: CoreML_Specification_WeightParams? = nil
    var _outputGateBiasVector: CoreML_Specification_WeightParams? = nil
    var _inputGatePeepholeVector: CoreML_Specification_WeightParams? = nil
    var _forgetGatePeepholeVector: CoreML_Specification_WeightParams? = nil
    var _outputGatePeepholeVector: CoreML_Specification_WeightParams? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _inputGateWeightMatrix = source._inputGateWeightMatrix
      _forgetGateWeightMatrix = source._forgetGateWeightMatrix
      _blockInputWeightMatrix = source._blockInputWeightMatrix
      _outputGateWeightMatrix = source._outputGateWeightMatrix
      _inputGateRecursionMatrix = source._inputGateRecursionMatrix
      _forgetGateRecursionMatrix = source._forgetGateRecursionMatrix
      _blockInputRecursionMatrix = source._blockInputRecursionMatrix
      _outputGateRecursionMatrix = source._outputGateRecursionMatrix
      _inputGateBiasVector = source._inputGateBiasVector
      _forgetGateBiasVector = source._forgetGateBiasVector
      _blockInputBiasVector = source._blockInputBiasVector
      _outputGateBiasVector = source._outputGateBiasVector
      _inputGatePeepholeVector = source._inputGatePeepholeVector
      _forgetGatePeepholeVector = source._forgetGatePeepholeVector
      _outputGatePeepholeVector = source._outputGatePeepholeVector
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._inputGateWeightMatrix)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._forgetGateWeightMatrix)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._blockInputWeightMatrix)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._outputGateWeightMatrix)
        case 20: try decoder.decodeSingularMessageField(value: &_storage._inputGateRecursionMatrix)
        case 21: try decoder.decodeSingularMessageField(value: &_storage._forgetGateRecursionMatrix)
        case 22: try decoder.decodeSingularMessageField(value: &_storage._blockInputRecursionMatrix)
        case 23: try decoder.decodeSingularMessageField(value: &_storage._outputGateRecursionMatrix)
        case 40: try decoder.decodeSingularMessageField(value: &_storage._inputGateBiasVector)
        case 41: try decoder.decodeSingularMessageField(value: &_storage._forgetGateBiasVector)
        case 42: try decoder.decodeSingularMessageField(value: &_storage._blockInputBiasVector)
        case 43: try decoder.decodeSingularMessageField(value: &_storage._outputGateBiasVector)
        case 60: try decoder.decodeSingularMessageField(value: &_storage._inputGatePeepholeVector)
        case 61: try decoder.decodeSingularMessageField(value: &_storage._forgetGatePeepholeVector)
        case 62: try decoder.decodeSingularMessageField(value: &_storage._outputGatePeepholeVector)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._inputGateWeightMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._forgetGateWeightMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._blockInputWeightMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._outputGateWeightMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._inputGateRecursionMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
      if let v = _storage._forgetGateRecursionMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }
      if let v = _storage._blockInputRecursionMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }
      if let v = _storage._outputGateRecursionMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      }
      if let v = _storage._inputGateBiasVector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
      }
      if let v = _storage._forgetGateBiasVector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
      }
      if let v = _storage._blockInputBiasVector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
      }
      if let v = _storage._outputGateBiasVector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
      }
      if let v = _storage._inputGatePeepholeVector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 60)
      }
      if let v = _storage._forgetGatePeepholeVector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
      }
      if let v = _storage._outputGatePeepholeVector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 62)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_LSTMWeightParams, rhs: CoreML_Specification_LSTMWeightParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._inputGateWeightMatrix != rhs_storage._inputGateWeightMatrix {return false}
        if _storage._forgetGateWeightMatrix != rhs_storage._forgetGateWeightMatrix {return false}
        if _storage._blockInputWeightMatrix != rhs_storage._blockInputWeightMatrix {return false}
        if _storage._outputGateWeightMatrix != rhs_storage._outputGateWeightMatrix {return false}
        if _storage._inputGateRecursionMatrix != rhs_storage._inputGateRecursionMatrix {return false}
        if _storage._forgetGateRecursionMatrix != rhs_storage._forgetGateRecursionMatrix {return false}
        if _storage._blockInputRecursionMatrix != rhs_storage._blockInputRecursionMatrix {return false}
        if _storage._outputGateRecursionMatrix != rhs_storage._outputGateRecursionMatrix {return false}
        if _storage._inputGateBiasVector != rhs_storage._inputGateBiasVector {return false}
        if _storage._forgetGateBiasVector != rhs_storage._forgetGateBiasVector {return false}
        if _storage._blockInputBiasVector != rhs_storage._blockInputBiasVector {return false}
        if _storage._outputGateBiasVector != rhs_storage._outputGateBiasVector {return false}
        if _storage._inputGatePeepholeVector != rhs_storage._inputGatePeepholeVector {return false}
        if _storage._forgetGatePeepholeVector != rhs_storage._forgetGatePeepholeVector {return false}
        if _storage._outputGatePeepholeVector != rhs_storage._outputGatePeepholeVector {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_UniDirectionalLSTMLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UniDirectionalLSTMLayerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputVectorSize"),
    2: .same(proto: "outputVectorSize"),
    10: .same(proto: "activations"),
    15: .same(proto: "params"),
    20: .same(proto: "weightParams"),
    100: .same(proto: "reverseInput"),
  ]

  fileprivate class _StorageClass {
    var _inputVectorSize: UInt64 = 0
    var _outputVectorSize: UInt64 = 0
    var _activations: [CoreML_Specification_ActivationParams] = []
    var _params: CoreML_Specification_LSTMParams? = nil
    var _weightParams: CoreML_Specification_LSTMWeightParams? = nil
    var _reverseInput: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _inputVectorSize = source._inputVectorSize
      _outputVectorSize = source._outputVectorSize
      _activations = source._activations
      _params = source._params
      _weightParams = source._weightParams
      _reverseInput = source._reverseInput
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._inputVectorSize)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._outputVectorSize)
        case 10: try decoder.decodeRepeatedMessageField(value: &_storage._activations)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._params)
        case 20: try decoder.decodeSingularMessageField(value: &_storage._weightParams)
        case 100: try decoder.decodeSingularBoolField(value: &_storage._reverseInput)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._inputVectorSize != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._inputVectorSize, fieldNumber: 1)
      }
      if _storage._outputVectorSize != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._outputVectorSize, fieldNumber: 2)
      }
      if !_storage._activations.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._activations, fieldNumber: 10)
      }
      if let v = _storage._params {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if let v = _storage._weightParams {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
      if _storage._reverseInput != false {
        try visitor.visitSingularBoolField(value: _storage._reverseInput, fieldNumber: 100)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_UniDirectionalLSTMLayerParams, rhs: CoreML_Specification_UniDirectionalLSTMLayerParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._inputVectorSize != rhs_storage._inputVectorSize {return false}
        if _storage._outputVectorSize != rhs_storage._outputVectorSize {return false}
        if _storage._activations != rhs_storage._activations {return false}
        if _storage._params != rhs_storage._params {return false}
        if _storage._weightParams != rhs_storage._weightParams {return false}
        if _storage._reverseInput != rhs_storage._reverseInput {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_BiDirectionalLSTMLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BiDirectionalLSTMLayerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputVectorSize"),
    2: .same(proto: "outputVectorSize"),
    10: .same(proto: "activationsForwardLSTM"),
    11: .same(proto: "activationsBackwardLSTM"),
    15: .same(proto: "params"),
    20: .same(proto: "weightParams"),
  ]

  fileprivate class _StorageClass {
    var _inputVectorSize: UInt64 = 0
    var _outputVectorSize: UInt64 = 0
    var _activationsForwardLstm: [CoreML_Specification_ActivationParams] = []
    var _activationsBackwardLstm: [CoreML_Specification_ActivationParams] = []
    var _params: CoreML_Specification_LSTMParams? = nil
    var _weightParams: [CoreML_Specification_LSTMWeightParams] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _inputVectorSize = source._inputVectorSize
      _outputVectorSize = source._outputVectorSize
      _activationsForwardLstm = source._activationsForwardLstm
      _activationsBackwardLstm = source._activationsBackwardLstm
      _params = source._params
      _weightParams = source._weightParams
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._inputVectorSize)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._outputVectorSize)
        case 10: try decoder.decodeRepeatedMessageField(value: &_storage._activationsForwardLstm)
        case 11: try decoder.decodeRepeatedMessageField(value: &_storage._activationsBackwardLstm)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._params)
        case 20: try decoder.decodeRepeatedMessageField(value: &_storage._weightParams)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._inputVectorSize != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._inputVectorSize, fieldNumber: 1)
      }
      if _storage._outputVectorSize != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._outputVectorSize, fieldNumber: 2)
      }
      if !_storage._activationsForwardLstm.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._activationsForwardLstm, fieldNumber: 10)
      }
      if !_storage._activationsBackwardLstm.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._activationsBackwardLstm, fieldNumber: 11)
      }
      if let v = _storage._params {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if !_storage._weightParams.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._weightParams, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_BiDirectionalLSTMLayerParams, rhs: CoreML_Specification_BiDirectionalLSTMLayerParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._inputVectorSize != rhs_storage._inputVectorSize {return false}
        if _storage._outputVectorSize != rhs_storage._outputVectorSize {return false}
        if _storage._activationsForwardLstm != rhs_storage._activationsForwardLstm {return false}
        if _storage._activationsBackwardLstm != rhs_storage._activationsBackwardLstm {return false}
        if _storage._params != rhs_storage._params {return false}
        if _storage._weightParams != rhs_storage._weightParams {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_CustomLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CustomLayerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    10: .same(proto: "className"),
    20: .same(proto: "weights"),
    30: .same(proto: "parameters"),
    40: .same(proto: "description"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 10: try decoder.decodeSingularStringField(value: &self.className)
      case 20: try decoder.decodeRepeatedMessageField(value: &self.weights)
      case 30: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,CoreML_Specification_CustomLayerParams.CustomLayerParamValue>.self, value: &self.parameters)
      case 40: try decoder.decodeSingularStringField(value: &self.description_p)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.className.isEmpty {
      try visitor.visitSingularStringField(value: self.className, fieldNumber: 10)
    }
    if !self.weights.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.weights, fieldNumber: 20)
    }
    if !self.parameters.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,CoreML_Specification_CustomLayerParams.CustomLayerParamValue>.self, value: self.parameters, fieldNumber: 30)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 40)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_CustomLayerParams, rhs: CoreML_Specification_CustomLayerParams) -> Bool {
    if lhs.className != rhs.className {return false}
    if lhs.weights != rhs.weights {return false}
    if lhs.parameters != rhs.parameters {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_CustomLayerParams.CustomLayerParamValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CoreML_Specification_CustomLayerParams.protoMessageName + ".CustomLayerParamValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    10: .same(proto: "doubleValue"),
    20: .same(proto: "stringValue"),
    30: .same(proto: "intValue"),
    40: .same(proto: "longValue"),
    50: .same(proto: "boolValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 10:
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {self.value = .doubleValue(v)}
      case 20:
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.value = .stringValue(v)}
      case 30:
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {self.value = .intValue(v)}
      case 40:
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {self.value = .longValue(v)}
      case 50:
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.value = .boolValue(v)}
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.value {
    case .doubleValue(let v)?:
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 10)
    case .stringValue(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 20)
    case .intValue(let v)?:
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 30)
    case .longValue(let v)?:
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 40)
    case .boolValue(let v)?:
      try visitor.visitSingularBoolField(value: v, fieldNumber: 50)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_CustomLayerParams.CustomLayerParamValue, rhs: CoreML_Specification_CustomLayerParams.CustomLayerParamValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_NeuralNetworkClassifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NeuralNetworkClassifier"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "layers"),
    2: .same(proto: "preprocessing"),
    100: .same(proto: "stringClassLabels"),
    101: .same(proto: "int64ClassLabels"),
    200: .same(proto: "labelProbabilityLayerName"),
  ]

  fileprivate class _StorageClass {
    var _layers: [CoreML_Specification_NeuralNetworkLayer] = []
    var _preprocessing: [CoreML_Specification_NeuralNetworkPreprocessing] = []
    var _classLabels: CoreML_Specification_NeuralNetworkClassifier.OneOf_ClassLabels?
    var _labelProbabilityLayerName: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _layers = source._layers
      _preprocessing = source._preprocessing
      _classLabels = source._classLabels
      _labelProbabilityLayerName = source._labelProbabilityLayerName
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._layers)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._preprocessing)
        case 100:
          var v: CoreML_Specification_StringVector?
          if let current = _storage._classLabels {
            try decoder.handleConflictingOneOf()
            if case .stringClassLabels(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._classLabels = .stringClassLabels(v)}
        case 101:
          var v: CoreML_Specification_Int64Vector?
          if let current = _storage._classLabels {
            try decoder.handleConflictingOneOf()
            if case .int64ClassLabels(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._classLabels = .int64ClassLabels(v)}
        case 200: try decoder.decodeSingularStringField(value: &_storage._labelProbabilityLayerName)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._layers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._layers, fieldNumber: 1)
      }
      if !_storage._preprocessing.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._preprocessing, fieldNumber: 2)
      }
      switch _storage._classLabels {
      case .stringClassLabels(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
      case .int64ClassLabels(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
      case nil: break
      }
      if !_storage._labelProbabilityLayerName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._labelProbabilityLayerName, fieldNumber: 200)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_NeuralNetworkClassifier, rhs: CoreML_Specification_NeuralNetworkClassifier) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._layers != rhs_storage._layers {return false}
        if _storage._preprocessing != rhs_storage._preprocessing {return false}
        if _storage._classLabels != rhs_storage._classLabels {return false}
        if _storage._labelProbabilityLayerName != rhs_storage._labelProbabilityLayerName {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_NeuralNetworkRegressor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NeuralNetworkRegressor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "layers"),
    2: .same(proto: "preprocessing"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.layers)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.preprocessing)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.layers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.layers, fieldNumber: 1)
    }
    if !self.preprocessing.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.preprocessing, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_NeuralNetworkRegressor, rhs: CoreML_Specification_NeuralNetworkRegressor) -> Bool {
    if lhs.layers != rhs.layers {return false}
    if lhs.preprocessing != rhs.preprocessing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
